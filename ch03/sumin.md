---
marp: true
---
# 3. 모듈성

* 모듈성은 일종의 구성 원리이다.
  아키텍트를 대충 아무렇게나 조각들을 이어 붙여 시스템을 설계하면 무수한 난관에 봉착해 옴짝달싹 못 하는 시스템이 되어버린다.
* 모듈성을 잘 유지하는 건 암묵적 아키텍처 특성이라고 정의한 것의 좋은 예가 된다.
  모듈이 확실히 구분되고 모듈 간 통신이 잘 되어야 한다고 공식적으로 아키텍트에게 요구하는 프로젝트는 드물지만, 암묵적으로 질서와 일관성이 필요하다.
---
## 3.1 정의
* 모듈 : 사전 - 복잡한 구조를 만드는데 쓰이는 각각의 표준화된 부품이나 독립적인 단위
    * 모듈성을 이용해 객체 지향 언어의 클래스나 함수형 언어의 함수가 될 만한 서로 연관된 코드를 논리적으로 묶는다.
    * 프로그래밍 언어는 대부분 모듈성 메커니즘을 제공하며, 개발자는 보통 연관된 코드를 함께 묶는 수단으로 모듈을 사용한다.
* 아키텍트는 개발자가 코드를 어떻게 패키징하는지 반드시 알아야 한다.
  여러 패키지가 서로 단단히 커플링되어 있으면 그 중 하나를 다른 작업에 재사용하기가 아주 어려워진다.
---
## 3.2 모듈성 측정
응집, 커플링, 커네이선스
### 3.2.1 응집
* 응집 : 한 모듈의 파트(구성 요소)가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다.
  모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가 하는 것
  '응집된 모듈을 나누려고 해봐야 더 커플링되고 가독성은 떨어진다'
---
    * 응집도의 측정 범위 정의
    1)기능적 응집
    모듈의 각 파트는 다른 파트와 연관되어 있고 기능상 꼭 필요한 모든것이 모듈에 들어 있다. 
    2) 순차적 응집
    두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력 받는 형태로 상호작용한다. 
    3) 소통적 응집
    두 모듈이 각자 정보에 따라 작동하고 어떤 출력을 내는 형태로 통신 체인을 형성한다. 
    4) 절차적 응집
    두 모듈은 정해진 순서대로 실행되어야 한다. 
    5) 일시적 응집
    모듈은 시점 의존성에 따라 연관된다. 
    6) 논리적 응집
    모듈의 내부 데이터는 기능적이 아니라 논리적으로 연관되어 있다. 서로 연관된 작업을이지만 하는 일은 전혀 다르다. 
    7) 동시적 응집
    같은 소스 파일에 모듈 구성 요소가 들어 있지만 그 외에는 아무 연관성도 없다.    

    * 메서드의 응집 결여도(LCOM) : 모듈의 구조적 응집도를 측정
    공유 필드를 통해 공유되지 않는 메서드의 총 개수
    LCOM의 모든 메트릭이 찾아내는 것은 구조적 응집 결여도일뿐, 일 메트릭만으로 어떤 조각들이 서로 잘 맞는지 논리적으로 판단할 수는 없다. 
---
### 3.2.2 커플링
구심 커플링 : 컴포넌트, 클래스, 함수 등의 코드 아티팩트로 유입되는 접속 수
원심 커플링 : 다른 코드 아티팩트로 유출되는 접속수
### 3.2.3 추상도, 불안정도, 메인시퀀스로부터의 거리
* 추상도 : 추상클래스, 인터페이스 등의 추상 아티팩트와 구상 아티팩트의 비율 ( 구현 대비 추상화 정도)
  아키텍트는 추상 아티팩트의 총 개수(인터페이스 또는 추상클래스)와 구상 아티팩트(비 추상 클래스) 의 총 개수로 추상도를 계산한다.
* 불안정도 : 원심 커플링과 (구심커플링 + 원심 커플링) 의 비율
  불안정도는 코드베이스의 변동성을 의미하므로 불안정도가 높은 코드베이스는 변경 시 커풀링이 높아 더 깨지기 쉽다.
---
* 메인 시퀀스로부터의 거리
  메인 시퀀스로부터의 거리는 아키텍처 구조를 평가하는 몇가지 전체적인 메트릭 중 하나로, 불안정도와 추상도를 이용하여 계산한다.
  추상도와 불안정도 사이의 이상적인 관계를 나타낸다.  
  이상적인 그래프를 기준으로 가까울수록 클래스 균형이 잘 맞고, 오른쪽 위로 치우치거나 ( 추상화를 많이 해서 사용하기 어려운 코드),
  왼쪽 아래로 치우친 부분 (추상화가 거의 없어 관리하기 힘든 코드)은 균형이 깨진 것을 의미한다.
---
### 3.2.5 커네이선스
* 정적 커케이선스 : 소스 코드 레벨의 커플링, 구심/원심 커플링을 발전시킨 개념.
    1) 명칭 커네이선스 :  여러 컨포넌트의 엔티티명이 일치해야한다. ex) 메서드명
    2) 타입 커네이선스 : 여러 컨포넌트의 엔티티 타입이 일치해야 한다. 변수와 매개변수를 특정 타입으로 제한하는 일반적인 기능
    3) 의미 커네이선스 / 관례 커네이선스 : 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야한다. ex) 상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견됨.
    4) 위치 커네이선스 : 여러 컴포넌트는 값의 순서가 일치해야 한다. 매개 변수의 순서 일치.
    5) 알고리즘 커네이선스 : 알고리즘이 일치해야 한다. 인증 결과가 같아야 한다.
---
* 동적 커네이선스 : : 런타임 호출을 분석한다.
    1) 실행 컨테이넌스 : 컴포넌트의 실행 순서가 중요하다.
    2) 시점 컨테이넌스 : 실행 시점이 중요하다.  ex) 동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 것
    3) 값 컨테이넌스 : 상호 연관된 다수의 값들을 함께 변경할 때 발생한다. ex) 트랜잭션
    4)  식별 커네이선스 : 동일한 엔티티를 참조할 때 발생. ex)독립적인 두 컴포넌트가 분산 큐 같은 자료 구조를 공유해서 업데이트
---
* 커네이선스 속성
    1) 강도 : 얼마나 쉽게 리팩토링 할 수 있는가
    - 지역성 : 코드베이스의 모듈들이 서로 얼마나 가까이에 있는가. 근접한 코드는 보통 더 분리된 코드보다 높은 형태의 커네이선스를 가진다.
    2) 지역성 : 코드베이스의 모듈들이 서로 얼마나 가까이 있는가
    3) 정도 : 커네이선스가 미치는 영향의 규모. 소스의 클래스에 영향을 미치는가, 아니면 수많은 클래스에 영향을 미치는가
    - 모듈성을 개선하는 3가지 방법
        - 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다.
        - 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다.
        - 캡슐화 경계 내부에서 커네이선스를 최대화한다.
    - 커네이선스 규칙
        - 정도의 규칙 : 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라
        - 지역성의 규칙 : 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라.
---
