## 3장. 모듈성

모듈성이란 무엇이고, 모듈성이 좋은지 나쁜지를 측정하는 몇가지 방법들을 소개 해준다.

### 3.1 정의

사전적 정의
'복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위'

연관된 코드를 함께 묶는 수단으로 모듈을 사용한다

* 히스토리
    * GOTO
        * 예전 프로그래밍 언어에서는 GOTO 문이 남용된 까닭에 코드 내의 비선형적인 흐름을 따라가기 어려웠음
    * 구조적 프로그래밍 언어의 등장
        * GOTO 문의 남용으로 파스칼, C로 대표되는 구조적 프로그래밍 언어가 등장
    * 모듈러 언어
        * 코드를 논리적으로 묶을 수 있는 방법이 마땅히 없었음
        * 그래서 Modula, Ada 같은 모듈러 언어가 등장
    * 객체 지향 언어
        * 코드를 캡슐화하여 재사용할 수 있음
        * 패키지, 네임스페이스 같은 형태로 모듈을 구현

### 3.2 모듈성 측정

모듈성을 측정하는 몇가지 도구들
응집, 커플링, 커네이선스

* 응집
    * 모듈의 구성 요소가 동일한 모듈 안에 얼마나 포함되어 있는가. 모듈의 구성 요소들이 서로 얼마나 연관되어 있는가
    * 응집도의 측정 범위
        * 기능성 응집
        * 순차적 응집
        * 소통적 응집
        * 절차적 응집
        * 일시적 응집
        * 논리적 응집
        * 동시적 응집
    * 예시
        * 고객 관리 / 주문 관리 두 모듈을 구성한다고 했을때..
            * 주문 관리에 작업이 2개 밖에 없다면? 굳이 나눠야하나?
            * 주문 관리 모듈이 동작하려면 고객 정보를 알아야하지 않나?
        * 이런 질문들의 답은 언제나 다르다. case by case
    * 메서드의 응집 결여도 측정 공식. LCOM
        * 공유 필드를 통해 공유되지 않는 메서드의 총 개수
* 커플링
    * 구심 커플링. incoming
    * 원심 커플링. outgoing
* 추상도
    * 추상도 공식
    * 불안정도 공식
* 메인 시퀀스로부터의 거리
    * 추상도와 불안정도를 통해 계산 가능
    * 개발자는 후보 클래스를 그래프로 그려보고, 이상적인 선에서 얼마나 떨어져 있는지를 볼 수 있다. 이때 너무 추상도가 심하면 '쓸모없는 구역'이 되고, 너무 추상화 되어 있지 않으면 '고통스런 구역'이 된다
* 커네이선스
    * 구심/원심 커플링 메트릭을 발전시킨 버전
    * 정적 커네이선스
        * 명칭 커네이선스
        * 타입 커네이선스
        * 의미 커네이선스 or 관례 커네이선스
        * 위치 커네이선스
        * 알고리즘 커네이선스
    * 동적 커네이선스
        * 실행 커네이선스
        * 시점 커네이선스
        * 값 커네이선스
        * 식별 커네이선스
    * 커네이선스 속성
        * 강도
            * 모듈성이 떨어지는 코드를 측정했다면, 그담으로 어떤 리팩토링을 통해 개선할 수 있을까?
            * 커네이선스 강도를 통해 리팩토링 순서를 정해볼 수 있다
        * 지역성
        * 정도 degree
            * 커네이선스가 미치는 영향의 규모. 작을수록 좋다

커플링과 커네이선스는 focus하는 영역이 다르지만, 아키텍트는 이것들을 통합해서 볼 줄 알아야한다

이 장에서 설명된 메트릭, 커플링, 커네이선스 같은 경우는..사실 코드의 세부 사항들에 가깝다
아키텍트는 동기 방식 or 비동기 방식. 이런 것들을 고민하지 그게 실제로 어떤 코드로 구현되는지에는 관심이 없다
