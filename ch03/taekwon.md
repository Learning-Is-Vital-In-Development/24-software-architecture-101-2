# CHAPTER 3

# Overview

플랫폼마다 제공하는 코드 재사용 매커니즘은 제각각이지만, 연관된 코드를 `모듈` 로 묶는 방법은 모두 지원 한다. 너무 당연하게 느껴지지만, 모듈성은 사실 제대로 정의하기 쉽지 않은 개념이다.

아키텍처가 분석해야할 많은 도구(메트릭, 피트니스 함수, 시각화 등)가 바로 이 모듈성에 기반하기 때문에 모듈성과 그것을 구현한 수많은 코드를 이해하는 것은 아키텍트에게 중요한 일이다.

모듈성을 잘 유지하는 건 우리가 암묵적 아키텍처 특성이라고 정의한 것의 좋은 예가 된다. 코드베이스를 잘 발전시켜 나가려면 암묵적으로 질서와 일관성이 필요하다.

# 정의

프로그래밍 언어는 대부분 모듈성 메커니즘을 제공하며, 개발자는 보통 연관된 코드를 `논리적` 으로 묶는 수단으로 모듈을 사용한다.

여러 패키지가 서로 단단히 `커플링` 되어있으면 그 중 하나르 다른 작업에 재사용하기 어려워진다.

보통 아키텍처를 논할 때 클래스, 함수처럼 코드를 묶어 놓은 덩어리를 모듈성이라는 일반 용어로 나타내는데, 이것은 논리적인 구분이지 물리적인 구분이 아니다.

따라서 모듈성은 특정 플랫폼에 함축되어 있거나 불가피한 물리적인 분리와 다른 개념으로 바라보는게 좋다.

## 응집

응집은 한 모듈의 파트(구성요소)가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다. 쉽게 말해 모듈을 구성하는 파트가 얼마나 연관되어 있는가 이다.

파트를 더 잘게 쪼개려면 모듈 간 호출을 통해 파트를 묶어야 유용한 결과를 얻을 수 있기에, 이상적으로 응집된 모듈은 모든 파트가 함께 패키징 되어있다.

(응집된 모듈을 나누려고 해봤자 더 커플링되고 가독성은 떨어진다.)

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/41757b84-be69-4742-b753-4b1b30cdf65e)

응집은 커플링보다는 덜 정확한 메트릭이므로 아키텍트 재략에 따라 측정된 모듈의 응집도는 다르다. 지속적인 확장 혹은 모듈간의 연관관계에 따라 응집도는 다를 수 있다.

LCOM(`메서드의 응집 결여도`)는 모듈의 구조적 응집도를 나타내며, 간단하게 다음과 같다.

<aside>
💡 공유 필드를 통해 공유되지 않는 메서드의 총 개수

클래스 안의 모든 속성이 전체 메소드에서 사용되고 있다면 응집도가 가장 높다고 말할 수 있고, 일부 속성이 특정 메소드에서만 사용된다면 응집도가 낮다고 말할 수 있다.

만일 클래스에서 어떤 메서드도 필드 값을 변경하지 않고 읽기만 한다면, 필드 간에 데이터를 공유하지 않는 것으로 간주되나, setter와 같이 필드값을 조작하는 경우 필드 간에 데이터를 공유하고 있다고 말 할 수 있다.(해당 조작이 다른 메소드에 영향을 주기 때문)

</aside>

LCOM의 모든 메트릭이 찾아내는 것은 `구조적` 응집 결여도일 뿐, 이 메트릭만으로 어떤 조각들이 서로 잘 맞는지 논리적으로 판단할 수는 없다. `왜` 가 더중요하다.

## 커플링

코드베이스의 커플링은 그래프 이론에 기반한 좋은 분석 도구들이 많이 있다. 메서드의 호출과 반환은 호출 그래프를 형성하므로 수학적인 분석이 가능하다.

`구심 커플링` , `원심 커플링` 을 비롯한 개념들이 있으며, 이때 구심의 경우 코드 아티팩트로 `유입`되는 접속 수를, 구심은 코드 아티팩트로 `유출`되는 접속 수를 나타낸다.

## 추상도, 불안정도, 메인 시퀀스로부터의 거리

코드베이스에는 추상화를 전혀 하지 않고 하나의 엄청나게 큰 함수 코드가 있는 코드베이스도 있고, 반대로 너무 지나치게 추상화해서 연관관계를 개발자가 파악하기 어려운 코드베이스도 있다.

**추상도**는 쉽게말해 우리가 작성한 코드의 추상화율을 수치화한 메트릭이다.

<aside>
💡 추상요소(인터페이스 또는 추상 클래스) / 구상 요소(코드, 비추상 클래스)

</aside>

**불안정도**는 코드베이스의 `변동성` 을 의미하므로 불안정도가 높은 코드베이스는 변경시 커플링이 높아 더 깨지기 쉽다.

<aside>
💡 원심(나가는) 커플링 / 원심(나가는 커플링) + 구심(들어오는) 커플링

</aside>

## 메인 시퀀스로부터의 거리

아키텍처 구조를 평가하는 몇 가지 전체적인 메트릭 중 하나로, 불안정도와 추상도를 이용하여 계산한다. 추상도, 불안정도는 비율이므로 항상 0 과 1 사이의 값이다.

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/4971a4d5-1174-4a76-9551-750496a400ff)

메인 시퀀스로부터의 거리는 추상도와 불안정도 사이의 이상적인 관계를 나타내며, 이상적인 선에 가까운 클래스는 서로 경쟁적인 두 메트릭의 건전한 조합이다.

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/98a26f9c-1b2e-4749-9f85-242503cbbd69)

각 구역에 따른 정의는 아래와 같다.

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/93e70a3a-cbbb-4c01-98c5-28ca2830f721)

[ArchUnit User Guide](https://www.archunit.org/userguide/html/000_Index.html#_component_dependency_metrics_by_robert_c_martin)

<aside>
💡 ArchUnit의 경우 기존 정의와는 다르게 추상성 값은 public class만을 기준으로 한다.(합리적)

</aside>

## 커네이선스

두 컴포턴트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 `커네이선스` 를 갖고 있는 것이다.

### 정적 커네이선스

소스 코드 레벨의 커플링 구심/원심 커플링을 발전시킨 개념이다.

- **명칭 커네이선스** : 여러 컴포넌트의 엔티티명이 일치해야 한다.
- **타입 커네이선스** : 여러 컴포넌트의 엔티티 타입이 일치해야 한다.
- **의미/관례 커네이선스** : 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.(TRUE/FALSE)
- **위치 커네이선스** : 여러 컴포넌트는 값의 순서가 일치해야 한다.(메서드 매개변수 순서)
- **알고리즘 커네이선스** : 여러 컴포넌트는 알고리즘이 일치해야 한다.

### 동적 커네이선스

런타임 호출을 분석하는 또 다른 유형의 커네이선스이다.

- **실행 커네이선스** : 여러 컴포넌트의 실행 순서가 중요하다.
- **시점 커네이선스** : 여러 컴포넌트의 실행 시점이 중요하다.(`race condition` 이 일반적 사례)
- **값 커네이선스** : 상호 연관된 다수의 값들을 함께 변경할 때 발생한다.(트랜잭션)
- **식별 커네이선스** : 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생한다.

### 카네이선스 속성

**[강도]**

아키텍트는 개발자가 어떤 유형의 커네이선스를 얼마나 쉽게 리팩터링할 수 있는지에 따라 커네이선스 `강도` 를 결정한다.

정적 커네이선스는 개발자가 간단히 소스 코드 분석하거나, 최신 도구를 활용하면 어렵잖게 개선할 수 있기 때문에 아키텍트는 정적 커네이선스를 더 선호한다.(명칭에 대한 정의 등)

**[지역성]**

코드베이스의 모듈들이 서로 얼마나 가까이 있는가 이다. 근접한 코드는 보통 더 분리된 코드보다 높은 형태의 커네이선스를 가진다.

모듈을 서로 떨어뜨렸을 때 커플링이 형편없는 형태의 커네이선스는 모듈을 붙여 놓는 식으로 개선할 수 있다.  개발자는 강도와 지역성을 함께 고민해야 한다.

**[정도]**

커네이선스가 미치는 영향의 규모에 관한 것으로 값이 작을 수록 코드베이스 입장에서 바람직하다.

- 시스템의 모듈성을 개선하는 세 가지 방법

    - 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화 한다.

    - 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화 한다.

    - 캡슐화 경계 내부에서 커네이선스를 최대화 한다.
