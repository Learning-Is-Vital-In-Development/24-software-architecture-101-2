## 모듈성

'모듈성은 일종의 구성 원리'
아키텍트가 아무렇게나 조각들을 이어 붙여 시스템을 설게하면
소프트웨어 시스템은 엔트로피가 증가하는 방향으로 움직이는 복잡한 시스템을 모델링하는것 과 같다.

---

### 정의

모듈의 사전적 정의

- 복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위
  > 우리는 모듈성을 이용해 객체 지향 언어의 클래스나 함수형 언어의 함수가 될만한 서로 연관된 코드를 **논리적** 으로 묶습니다.

아키텍처를 논할 때 클래스, 함수처럼 코드를 묶어 놓은 덩어리를 모듈성이라는 일반용어로 나타낸다.
이것은 논리적인 구분이지 물리적인 구분은 아니지만, 이 차이점이 굉장히 중요한 경우가 있다.
ex 모놀리식 애플리케이션은 편의상 많은 클래스를 한 덩이로 묶어도 상관없지만, 아키텍처를 재구축할 때에는 이렇게 커플링된 구조가 모놀리스를 나누는 데 걸림돌이 된다.

---

### 모듈성 측정

- 응집, 커플링, 커네이선스

#### 응집

응집은 한 모듈의 파트(구성 요소)가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다.

- 모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가,

응집도의 측정 범위 (좋은 것 => 나쁜 것)

- 기능적 응집
  - 모듈의 각 파트는 다른 파트와 연관되어 있고 기능상 꼭 필요한 모든 것이 모듈에 있다.
- 순차적 응집
  - 두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력 받는 형태로 상호작용한다.
- 소통적 응집
  - 두 모듈이, 각자 정보에 따라 작동하고 어떤 출력을 내는 형태로 통신 체인을 형성 (ex. 데이터베이스에 레코드를 추가 => 이메일 생성)
- 절차적 응집
  - 두 모듈은 정해진 순서대로 실행
- 일시적 응집
  - 모듈은 시점 의존성에 따라 연관된다.(ex.많은 시스템들이 시동할때 관련이 없어보이는 것들이 초기화 되는 경우)
- 논리적 응집
  - 모듈의 내부 데이터는 기능적이 아니라 논리적으로 연관되어 있다. (ex. 텍스트, 직렬화, 스트림 형태로 받은 데이터를 변환하는 모듈)
- 동시적 응집
  - 같은 소스 파일에 모듈 구성 요소가 들어 있지만 그 외에는 아무 연관성이 없는것

컴퓨터 과학자들은 응집의 주관성을 전제로 응집도를 가늠할 수 있는 구조적 메트릭을 개발했다.
**카이댐버와 케메러의 객체 지향 메트릭 스위트**는 객체 지향 소프트웨어 시스템의 특정 부분을 측정하는 유명한 메트릭 세트이다.

---

### 커플링

구심 커플링 - 코드 아티팩트로 유입되는 접속 수
원심 커플링 - 다른 코드 아티팩트로 유출되는 접속 수

추상도 = 추상 아티팩트와 구상 아티팩트의 비율 => 구현 대비 추상화 정도
메인 시퀀스로부터의 거리는 아키텍처 구조를 평가하는 몇 가지 전체적인 메트릭 중 하나로, 불안정도와 추상도를 이용해서 계산
메인 시퀀스와 추상도와 불안정도가 만나는지점이 가까울수록 클래스 균형이 잘 맞는다는 방증이다.

---

### 커네이선스

> 두 컨포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다. 밀러 페이지-존스

#### 정적 커네이선스

- 소스 코드 레벨의 커플링 (구심/원심 커플링을 발전시킨 개념)

  - 아키텍트는 구심적이든, 원심적이든 다음 종류의 정적 커네이선스를 뭔가에 커플링된 정도라고 본다.

- 명칭 커네이선스
  - 여러 컨포넌트의 엔티티명이 일치해야 한다.
    - 메서드명은 코드베이스가 커플링되는 가장 일반적이면서 바람직한 방법이다.
- 타입 커네이선스
  - 여러 컨포넌트의 엔티티 타입이 일치해야 한다.
    - 대부분의 정적 타입 언어에서 변수와 매개변수를 특정 타입으로 제한하는 일반적인 기능이다.
- 의미 커네이선스 or 관례 커네이선스
  - 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.
    - 이런 종류의 커네이선스는 상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견된다.
- 위치 커네이선스
  - 여러 컴포넌트는 값의 순서가 일치해야 한다.
    - 정적 타이핑이 가능한 언어에서도 메서드와 함수 호출 시 전달하는 매개변수 값은 순서가 맞아야 한다.
- 알고리즘 커네이선스
  - 여러 컨포넌트는 특정 알고리즘이 일치해야 한다.
    - 서버/클라이언트 둘다 실행되야 하고 유저 인증시 동일 결과를 내야하는 보안 해시 알고리즘이 있다. 커플링이 심하다

#### 동적 커네이선스

- 동적 커네이선스는 런타임 호출을 분석하는, 페이지-존스가 정의한 또 다른 유형의 커네이선스이다.

- 실행 커네이선스
  - 여러 컴포넌트의 실행 순서가 중요하다.(순서를 지키지 않으면 제대로 동작하지 않는다.)
- 시점 커네이선스
  - 여러 컴포넌트의 실행 시점이 중요하다.(동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 것)
- 값 커네이선스
  - 상호 연관된 다수의 값들을 함께 변경할 때 발생한다. (ex. 트랜잭션)
- 식별 커네이선스
  - 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생한다.
    - ex. 독립적인 두 컴포넌트가 분산 큐 같은 자료 구조를 공유해서 업데이트 하는 경우
    - 런타임 호출은 호출 그래프에 비해 효과적인 분석 도구가 많지 않아 아키텍트는 동적 커네이선스를 파악하기 쉽지 않다.

---

### 커네이선스 속성

#### 강도

- 정적 커네이선스는 코드 분석 및 최신 도구를 활용하면 개선이 어렵지 않다.
  - ex.의미 커네이선스에서 매직 밸류 대신 기명 상수를 만드는 명칭 커네이선스로 리팩터링 하면 의미 커네이선스가 개선될 것이다.

#### 지역성

- 커네이선스의 지역성은 코드베이스의 모듈들이 서로 얼마나 가까이 있는가 이다.
  - 동일한 모듈에서 근접한 코드는 보통 별개의 모듈 또는 코드베이스로 더 분리된 코드보다 높은 형태의 커네이선스를 가진다.
    > 동일한 모듈에서 더 강한 형태의 커네이선스가 발견된다면 동일한 커네이선스가 널리 흩어져 있는 것보다는 코드 스멜이 덜하다는 증거 이다.

#### 정도

- 커네이선스의 정도는 커네이선스가 미치는 영향의 규모(영향 받는 클래스의 수)에 관한 것이다.

  - 적을수록 코드베이스 입장에서는 바람직하다.

- 페이지-존스가 제시한, 커네이선스를 이용해 시스템의 모듈성을 개선하는 세 가지 방법

  - 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다.
  - 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다.
  - 캡슐화 경계 내부에서 커네이선스를 최대화 한다.

- 정도의 규칙
  - 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환
- 지역성의 유칙
  - 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라

#### 커플링과 커네이선스 매트릭을 통합

구조적 프로그래밍은 들어오고 나가는 것에만 관심이 있는 반면, 커네이선스는 여러 가지 요소가 서로 어떻게 커플링되는지에 주목한다.

#### 90년대 커네이선스의 문제점

- 매트릭은 아키텍처 구조보다는 저수준 코드의 세부분을, 코드 품질 및 정리 상태 위주로 관찰한다.
  - 아키텍트는 동기 통신이냐, 비동기 통신이냐를 고민하고, 어떻게 구현할지에는 별로 관심이 없다.
- 사실 커네이선스 자체는 요즘 아키텍트가 내려야 할 근본적인 결정에 관한 문제를 다루지 않는다.

---

### 모듈에서 컴포넌트로

연관된 코드의 묶음을 '모듈'이라는 일반 용어로 표현하지만, 대부분의 플랫폼은 소프트웨어 아키텍트에게 핵심 구성 요소 중 하나인 '컴포넌트' 형태로 지원한다.
