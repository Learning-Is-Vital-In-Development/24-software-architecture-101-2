## 13장. 서비스 기반 아키텍처 스타일

마이크로 서비스 아키텍처 스타일의 일종

기본 토폴로지
* 유저 인터페이스
* 원격 서비스
* 모놀리스 데이터베이스

'서비스'는 큼지막한 단위로 분리해 별도로 배포하는 애플리케이션의 일부
중앙 공유 데이터베이스를 사용할 수도 있고, 별도의 데이터베이스들을 사용할 수도 있다

다양한 토폴로지 구성이 가능
* 단일 모놀리식 유저 인터페이스
* 도메인 기반 유저 인터페이스
* 서비스 기반 유저 인터페이스
* 모놀리식 데이터베이스를 각 도메인 서비스 전용 데이터베이스들로 분리
* 유저 인터페이스와 서비스 사이에 API 레이어(프록시, API 게이트웨이)를 두는




서비스 컴포넌트를 기술 분할 / 도메인 분할 가능
어떻게 설계하든 앞단에 'API 파사드 레이어'가 존재

API 파사드 레이어는 유저 인터페이스로 인입된 비즈니스 요청을 오케스트레이트합니다.
예를 들면, 주문이 접수되면 OrderService에서는 주문 처리, 주문 ID 생성, 결제 처리, 재고 업데이트 등의 일련의 작업을 오케스트레이트합니다.

만약 마이크로서비스 아키텍처에서 처리한다면 별도 배포된 다수의 전용 원격 서비스를 오케스트레이트해야 합니다.
**이것이 서비스 기반 아키텍처와 마이크로서비스 아키텍처의 중요한 차이**

> 결국 마이크로 서비스 아키텍처의 한 타입이고, '서비스'라는게 별도의 애플리케이션(별도의 라이프 사이클을 가지는)으로 분리하는 것은 아닌

데이터 무결성을 보장하기 위한 ACID -> 강한 일관성
마이크로서비스처럼 분산도가 높은 아키텍처에서는 BASE -> 최종 일관성. ACID 레벨의 데이터 무결성 보장 못함
주문을 예로 들면, 주문은 생성했는데, 결제가 실패해서 주문이 남아있게되는 상황도 가능

### 서비스 기반 아키텍처, 마이크로 서비스 아키텍처 비교

* 비즈니스 요청 오케스트레이트
    * 서비스 기반 아키텍처: 다른 도메인 서비스들을 메서드 호출하면서 처리하면됨
    * 마이크로 서비스 아키텍처: 다른 서버, API를 호출해야됨
* 데이터 무결성 보장
    * 서비스 기반 아키텍처: ACID
    * 마이크로 서비스 아키텍처: BASE 최종일관성
* 테스트, 배포
    * 서비스 기반 아키텍처: 전체 테스트, 전체 배포 필요
    * 마이크로 서비스 아키텍처: 일부만 테스트, 배포 가능. 배포가 잘못되어도 영향을 최소화하는게 가능

### 데이터베이스 분할

* 단일 모놀리식 데이터베이스
    * 문제점: 테이블 스키마 변경시 모든 서비스 수정 필요
        * 그래서 커스텀 공유 라이브러리에 테이블 스키마 보관하긴 하지만..
    * 데이터베이스를 논리적으로 분할하면 좀 더 개선 가능
        * 공통, 고객, 청구, 주문, 추적. 5개 도메인으로 나누고 공유 라이브러리에 둔다. 필요한 것만 서비스에서 사용한다
    * 공통 엔티티 객체를 버전 관리 시스템에서 락킹하고, 수정 권한을 오직 데이터베이스 팀에게만 부여하는 것

> domain module을 아예 별도 모듈로 분리해서 관리하거나..
> flyway, liquibase로 관리하는게 떠오르네..

### 13.5 아키텍처 예시

재활용 시스템
* 견적: 고객이 중고 제품의 가격을 문의
* 수취: 고객이 중고 제품을 보냄
* 감정: 제품의 작동 상태를 감정
* 회계: 보상가를 지불
* 제품 상태: 진행 상황 조회
* 재활용: 재활용 or 재판매
* 리포팅: 임시/정기 재무 리포트 제공

각 도메인 영역을 개별 배포되는 독립적인 도메인 서비스로 구현
데이터베이스를 외부 제공, 내부 제공으로 분리

> 근데 독립적인 도메인 서비스로 배포? 이건 마이크로 서비스 아닌가...그럼 데이터베이스를 같이 쓴다는 점만 다른건가?


### 언제 사용하면 좋을까

어쩌면 가장 실용적인 아키텍쳐

도메인 주도 설계와 궁합이 잘 맞음
서비스를 큰 단위로 나누고 그 범위를 도메인으로 한정 가능

다른 분산 아키텍처에 비해서 ACID 트랜잭션이 잘 보존된다
대부분의 트랜잭션이 특정 도메인 서비스에 한정되므로 모놀리식의 커밋/롤백 트랜잭션이 가능하다

> 근데 마이크로 서비스 아키텍처를 한다고 해도..도메인 단위로 나누지 않나?
당장 주문만 봐도...주문, 쿠폰, 결제 이런 도메인들에 다 걸쳐있어서 모놀리식의 커밋/롤백이 불가능하다

여러 서비스를 조율해서 비즈니스 트랜잭션을 완성하려면
오케스트레이션과 코레오그래피가 모두 필요

오케스트레이션: 트랜잭션의 워크플로를 제어/관리. 중재자 서비스를 따로 두고 여러 서비스를 관리하는 기법
코레오그래피: 중앙의 중재자 서비스 없이 서로 알아서 소통

> Saga Pattern (로컬 트랜잭션의 시퀀스, 이벤트 기반)을 말하는듯..
'분산 트랜잭션 없이도 여러 서비스에서 데이터 일관성을 유지하는게 가능'

> 사가 패턴을 구현하는 두가지 방법
Choreography: 각 로컬 트랜잭션이 다른 서비스에서 로컬 트랜잭션을 트리거하는 도메인 이벤트를 게시합니다.
Orchestration: 오케스트레이터(객체)가 참가자에게 어떤 로컬 트랜잭션을 실행할지 알려줍니다.
