---
marp: true
---
# 13. 서비스 기반 아키텍처 스타일
---
* 토폴로지 : 각각 따로 배포된 유저 인터페이스와 원격 서비스, 모놀리스 데이터베이스로 이루어진 대규모 분산 레이어 구조
* 각각 단일 인스턴스로 배포하지만, 확장성, 내장성, 처리량 요구사항에 따라 인스턴스를 여럿 둘 수도 있다.
    - 서비스 인스턴스를 다수 생성하여 배포하려면 유저 인터페이스로 유입된 요청이 가용한 서비스 인스턴스로 흘러갈 수 있도록 유저 인터페이스와 도메인 서비스 간의 부하 분산 기능이 필요하다
* 중앙 공유 데이터베이스를 사용한다는 특징이 중요하다

---
* 서비스 기반 아키텍처 스타일은 특유의 유연성때문에 정말 다양한 변형이 존재한다.
    - 단일 모놀리식 유저 인터페이스, 여러 유저 인터페이스 도메인으로 나누기, 도인 서비스에 맞게 나누기
    - 개별 데이터베이스로 분리할수도 있다. 각 도메인 서비스 전용 데이터베이스로 쪼개기 ( 단, 각 데이터베이스에 있는 도메인 데이터를 다른 도메인의 서비스가 필요로 하 않도록 설계)
    - 리버스 프록시, 게트웨이로 구성된 API 레이어를 유저 인터페이스와 서비스 사이에 구성하기 ( 외부시스템에 표출하거나 공통 관심사를 통합해서 유저 인터페이스 밖으로 떼어낼 경우 유용함)
---
* 도메인 서비스를 api 퍼사드 레이어, 비즈니스 레이어, 퍼시스턴스 레이어로 구성된 레이어드 아키텍처 스타일로 설계한다.
    - api 퍼사드 레이어 : 유저인터페이스를 통해 유입된 비즈니스 요청을 조정,조율하는 역할
* 단일 도메인 서비스: ACID DB 트랜잭션 , 마이크로서비스: BASE 분산 트랜잭션
    - 서비스 기반 아키텍처의 ACID 레벨의 데이터 무결성은 지원하지 않는다.

* 단일 모놀리식 데이터베이스를 공유할 경우
    * DB 구조를 조금이라도 변경할 일이 있으면 전체 서비스를 변경후 재배포. 어느 서비스가 실제로 어떻게 영향을 받을지 예측하기 어려움
    * DB 변경영향도와 리스크를 낮추는 방법 : DB를 논리적으로 분할. 논리 분할을 연합 공유 라이브러리를 통해 명시
---
* 서비스 기반 아키텍처는 도메인주도 설계와 궁합이 잘 맞는다.
* 기능을 단일 소프트웨어 단위로 구분하면 변경도 쉽다.
* 다른 분산 아키텍처에 비해 ACID 트랜잭션이 더 잘 보존된다.  