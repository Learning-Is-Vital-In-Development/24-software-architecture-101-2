# CHAPTER 6

# 아키텍처 특성 측정

아키텍처 특성을 정의할 때에는 흔히 다음과 같은 문제들이 발생한다.

**[물리학이 아니다]**

동일한 용어도 업계에서 바라보는 시각이 제각각이고 법적인 상황에 따라 좌지우지되거나 우발적으로 의미가 정해지는 경우도 있다.

**[정의가 너무 다양하다]**

성능 같은 중요한 특성에 대한 정의가 같은 조직에서도 부서마다 일치하지 않아 개발자, 아키텍트, 운영자 모두 정의를 통일하기 전까지는 원활한 소통을 하기 어렵다.

**[너무 복합적이다]**

아키텍처 특성을 명확하게 정의하고 조직 전체가 이에 동의하면 팀은 공통의 아키텍처 언어를 확립할 수 있다. 또한 복합적인 특성은 더 잘게 나누어 분석해보면 객관적으로 정의할 수 있는 측정 가능한 특성을 밝혀낼 수 있다.

## 운영적 측정

아키텍처 특성은 성능, 확장성 처럼 비교적 정확하게 측정할 수 있는 것도 많지만, 팀 목표에 따라 그에 따른 해석은 미묘하게 갈릴 때가 많다.

수준 높은 팀은 달성하기 어려운 성능 수치를 정하는 대신, 통계 분석 결과로 얻은 나름대로의 정의에 기반한다.

## 구조적 측정

내부 코드 품질에 대한 종합적인 메트릭은 없지만, 아키텍트는 다른 메트릭과 공통 도구를 이용해서 코드 구조에 관한 중요한 부분을 들여다 볼 수 있다.

코드의 복잡도는 `순환 복잡도(CC)` 라는 메트릭을 통해 측정이 가능하다.

<aside>
💡 **cyclomatic complexity(CC)**
코드 레벨의 메트릭으로 함수/메서드, 클래스 또는 애플리케이션 레벨에서 코드 복잡도를 객관적으로 나타내는 지표.

**공식 : CC = E(가능한 결정(간선)) - N(코드라인) + 2(단일/ 함수/메서드를 단순화한 값)**

다른 메서드도 호출하는 경우까지 고려한 일반 공식은
**CC = E - N + 2P** 이다.

</aside>

이키텍트, 개발자 모두 너무 복잡한 코드는 곧 코드스멜 이라는 사실에 공감하며, 이런 코드는 코드베이스 특성을 저해하는 요소이다.

**테스트 주도 개발(TDD)** 같은 엔지니어링 프랙티스는 주어진 문제 영역에서 대체로 더 작고 덜 복잡한 메서드를 생성하는, 긍정적인 효과를 가져온다. 이처럼 구체적인 동작과 명확한 테스트 경계에 집중하면 짜임새 있고 고도로 응집된 메서드를 개발할 수 있으며, CC 값도 낮게 나올 수 있다.

## 프로세스 측정

**민첩성**은 소프트웨어 개발 프로세스와 교차하는 아키텍처 특성으로 시험성, 배포성 등의 특성으로 나눌 수 있는 복합적인 아키텍처 특성이다.

**시험성**은 거의 모든 플랫폼에서 테스트의 완전성을 평가하는 코드 커버리지 도구로 측정할 수 있다. 물론 `사고` 와 `의도` 를 대체할 순 없지만 분명히 객관적으로 측정할 수 있는 특성이다.

**배포성** 역시 실패 대비 배포 성공률(%), 배포 소요시간, 배포시 발생한 이슈/버그 등 다양한 메트릭으로 측정되며 이렇게 측정한 메트륵들은 실제로 대부분 팀의 우선순위 목표가 된다.

민첩성과 이와 관련된 부분은 분명히 소프트웨어 개발 프로세스와 연관이 있지만, 아키텍처 구조에도 영향을 미칠 수 있다. 이는 아키텍처 특성이 구조를 주도하는 좋은 예이다.

## 거버넌스와 피트니스 함수

아미텍트가 아키텍처 특성을 확정한 후 우선순위를 정하면 개발자들이 이 우선순위를 잘 지킬거라 확신할 수 있는가? 일반적으로 소프트웨어 프로젝트에서 긴급성을 무시할 수는 없지만 그래도 아키텍트는 거버넌스 매커니즘을 강구해야 한다.

## 아키텍처 특성 관리

거버넌스는 아키텍트가 담당하는 중요한 업무이다. 아키텍처 커버넌스는 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄한다.

예를 들어, 조직 내부에서 소프트웨어 품질 보장 업무는 아키텍처 범주 안에 속하므로 아키텍처 거버넌스 항목이다.

## 피트니스 함수

결과가 목표에 얼마나 근접했는지를 나타내는 목표 함수가 바로 피트니스 함수로 이 개념을 차용해 아키텍처 피트니스 함수가 정의 되었다.

**[아키텍처 피트니스 함수]**

어떤 아키텍처 특성의 객관적인 무결성을 평가하는 모든 메커니즘을 말한다. 피트니스 함수는 아키텍트가 그냥 다운로드 받아 사용하는 새로운 프레임워크가 아닌 수많은 기존 도구들을 바라보는 새로운 시각이다.

아키텍처 특성을 검증하는 기법은 그 특성만큼이나 다양하며, 피트니스 함수는 사용하는 방법에 따라 메트릭, 모니터, 단위 테스트 라이브러리, 카오스 엔지니어링 등 기존의 많은 검증 메커니즘과 중첩되는 부분이 있다.

### 순환 의존성

모듈성은 대부분의 아키텍트가 관심을 기울이는 암묵적인 아키텍처 특성이다. 모듈성이 제대로 유지되지 못하면 코드베이스 구조에 해를 끼치므로 우선순위를 높게 두어 관리할 수밖에 없다.

그럼에도 불구하고 개발자는 일종의 반사 작용처럼 자동 임포트의 관성에 빠지게 되며, 각 컴포넌트가 다른 컴포넌트에 있는 코드를 참조하게 되는 순환 의존성이 생긴다.

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/9033649f-ad96-4a81-a19b-a6d1159350df)

이런 식으로 컴포넌트 망이 형성되면 개발자가 어느 한 컴포넌트를 재사용하기 위해 그에 딸린 다른 컴포넌트들도 함께 가져와야 하므로 모듈성이 매우 떨어진다.

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/d67c14ca-d726-46d6-83e1-0509a991ae15)

코드리뷰는 도움은 되지만 개발 주기상 시기가 너무 늦어 비효율 적이며, JDepend라는 메트릭 도구로 패키지간 의존성 체크가 가능하며, 이 도구는 순환 참조가 하나라도 존재하면 테스트는 실패한다.

이는 소프트웨어 개발에서 신속한 진행보다 중요한 것을 수호하는 피트니스 함수의 좋은 사례이다.

<aside>
💡 **DIP(의존성 역전 원칙)**
의존성 양쪽 코드를 모두 제어할 수 있다는 전제 하에 의존성 역전을 통해 순환의존성을 끊어 낼 수 있다.(인터페이스를 통한 의존성 역전)

아래와 같이 구성할 경우 영속성 레이어의 변경에 따라 도메인 엔티티가 영향을 받는
(JPA → MyBatis) 상황을 끊어낼 수 있다.

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/9dc44213-dfc2-4240-87d4-05204c1d1f6b)

</aside>

## 메인 시퀀스로부터의 거리 피트니스 함수

만일 레이어드 모놀리스를 설계할 때 아키텍트는 정당한 사유 등을 내세워 레이어를 정의 하지만 개발자들이 잘 지켜서 개발하리라 확신할 수 없다.

구현하는 사람들이 아키텍처 근본을 침해해도 아무런 조치를 취하지 않으면 장기적으로 아키텍처의 건전성을 해치고 만다.

이 문제는 `ArchUnit` 로 피트니스 함수를 이용해 해결할 수 있다. 넷플릭스의 `카오스 멍키` `시미안 아미` 등도 피트니스 함수의 응용 사례이다.

피트니스 함수는 무거운 거버넌스 메커니즘보다는 아키텍트가 중요한 아키텍처 원칙을 표현하고 자동으로 검증할 수 있는 메커니즘을 제공한다.

구체적인 도구와 피트니스 함수 같은 일반적인 도구를 잘 활용하면 중요한 거버넌스 체크를 아키텍처 하부에 구체화할 수 있다.
