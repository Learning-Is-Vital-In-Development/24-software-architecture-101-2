# 마이크로서비스 아키텍처 스타일

## 역사

- 대부분의 아키텍처 스타일은 반복적으로 나타나는 패턴을 처음 발견한 아키텍트의 이름을 따서 명명
- 하지만 마이크로서비스는 마틴 파울러와 제임스 루이스가 쓴 Microservices 라는 블로그 게시물 덕분에 퍼지게 됨
- DDD 영향을 많이 받음
    - 디커플링 스타일을 나타낸 경계 컨텍스트 개념이 큰 영향
    - 마이크로서비스의 주요 목표는 경계 콘텍스트의 논리적 개념을 물리적으로 모델링하려는 고도의 디커플링

## 토폴로지

- 단일 목적만 가지기 때문에 오케스트레이션 기반의 서비스 지향 아키텍처와 같은 다른 분산 아키텍처보다 서비스 규모가 훨씬 작다.

## 분산

- 분산 아키텍처를 형성
    - 서비스는 자체 프로세스로 실행
    - 애플리케이션을 호스트하는 육중한 멀티테넌트 인프라 아키텍처에서 자주 발생하는 문제들을 간단히 해결 가능 (네트워크 대역폭, 메모리, 디스크 공간)
- 공유함으로써 불거지는 문제
    - 각 서비스를 자체 프로세스로 분리하면 자연스럽게 해소
- 성능은 부정적
    - 네트워크 호출은 메소드 호출보다 오래 걸림
    - 엔드포인트마다 보안 검증 절차를 거치면 소요 시간 증가
- 서비스 경계를 넘나드는 트랜잭션을 사용하지 않도록 권고

## 경계 콘텍스트

- 커플링보다는 중복이 낫다고 생각
    - 도메인 분할 아키텍처의 개념을 극도로 우려낸 결과물
- 세분도
    - 마이크로서비스의 알맞은 세분도를 찾기 위해 고심하다가 서비스를 너무 잘게 나누는 실수를 하기도 함
    - 적절한 경계를 찾기 위한 가이드라인
        - 목적 : 도메인의 목적
        - 트랜잭션 : 여러 엔티티가 함께 개입하여 작동하는 트랜잭션은 좋은 서비스 경계 후보
        - 코레오그래피 : 도메인 격리는 잘 되어 있지만 광범위한 통신을 해야 제대로 작동되는 서비스 세트는 큰 서비스로 다시 뭉치는 것을 고려
- 데이터 격리
    - 경계 콘텍스트 개념에 따라 데이터를 격리
    - 통합 지점으로 사용되는 공유 스키마, 데이터베이스 등 모든 종류의 커플링을 없앰
    - 서비스를 단순히 데이터베이스에 있는 엔티티와 비슷하게 모델링해서는 안 됨
    - 기존 : 관계형 데이터베이스로 통합하여 단일 진실 공급원을 만들기
    - 마이크로서비스 : 도메인을 어떤 팩트에 대한 진실 공급원으로 식별하여 그 값을 가져올 수 있게 조정하든지, 데이터베이스 복제나 캐시 기술로 정보를 분산시키든지의 방안 필요
    - 긍정적인 부분 : 단일 데이터베이스의 속박에서 벗어나 각 서비스에 맞는 적합한 데이터베이스를 선택할 수 있고 구현체 세부에 얽매이지 않음

## API 레이어

- 마이크로서비스의 기본 철학에 충실하려면 API 레이어를 중재자나 오케스트레이션 도구로 사용하지 말아야 한다.
    - 모든 비즈니스 로직은 경계 콘텍스트 내부에서 일어나야 한다.
    - 기술 분할 서비스에서 중재자 사용

## 운영 재사용

- 모니터링, 로깅, 회로 차단기 등의 재사용이 유리한 컴포넌트는 sidecar pattern 활용
- 각 서비스에는 공통 사이드카가 포함돼있으므로 서비스 메시를 구축하면 일월화하여 제어 가능
    - 서비스 메시 : 개발자가 서비스를 전체적으로 액세스할 수 있는 콘솔 역할
    - 전체 메시에서 각 서비스는 하나의 노드
    - 아키텍트는 마이크로서비스에 탄력성을 부여하는 수단으로 서비스 디스커버리를 사용 → 서비스를 직접 호출하는 게 아니라 서비스 디스커버리를 거쳐서 호출하도록 하여 모니터링/필요시 서비스 인스턴스를 늘릴 수 있다.

## 프런트엔드

- 두 가지 스타일 존재
    - 모놀리식 유저 인터페이스와 접목한 마이크로서비스
    - 마이크로프런트엔드

## 통신

- 프로토콜 인지 이종 간 상호 운영성을 통해서 통신을 결정
    - 프로토콜 인지 : 중앙 통합 허브가 없기 때문에 각 서비스는 다른 서비스를 호출하는 방법을 알고 있어야 한다.
    - 이종 : 각 서비스마다 구현 기술 스택이 상이 (폴리글랏)
    - 상호 운용성 : 여러 서비스가 서로 호출
- 코레오그래피와 오케스트레이션
    - 코레오그래피 : 브로커 이벤트 기반의 아키텍처와 통신 스타일이 동일. 중재자가 따로 없고 경계 콘텍스트 철학에 충실
    - 코레오그래피에서 각 서비스는 중앙 중재자 없이 자신의 필요에 따라 다른 서비스를 호출
        - 프론트 컨트롤러 패턴 : 한 서비스가 명목상 더 복잡한 중재자 노릇을 함 → 서비스 복잡도가 증가
        - 오케스트레이션을 두어 복잡한 처리를 담당하면서 조정 역할도 수행 → 서비스 간 커플링은 발생하지만 한 서비스가 조정 작업을 전담하므로 다른 서비스는 거의 영향을 받지 않음
- 트랜잭션과 사가
    - 서비스 결계를 넘나드는 트랜잭션은 디커플링 원칙에 위배
        - 지나치게 세분화했기 때문에 발생
        - 컴포넌트 세분도를 바로 잡아야 한다.
        - 예외도 존재
    - 사가 패턴
        - 중재자 서비스가 트랜잭션을 관리하며 각 서비스는 요청 처리 후 보류해 두고, 중간에 작업이 실패한 경우 undo 요청을 보냄
        - 비동기 요청, 보류된 트랜잭션 상태에 따른 새로운 요청 → 복잡도 증가
        - 트랜잭션마다 do/undo 로직을 개발하는 식으로 작업 → undo 작업이 do 작업보다 엄청나게 복잡
    - 이럴거면 굳이 마이크로서비스 패턴을 선택할 이유가 없다.

## 아키텍처 특성 등급

- 확장성, 탄력성, 진화성
- 성능 문제
    - 과도한 네트워크 호출을 줄이고 성능을 개선하기 위해 데이터 캐시, 데이터 복제 등의 기술 활용