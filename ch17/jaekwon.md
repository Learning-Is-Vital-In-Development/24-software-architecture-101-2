## 17장. 마이크로서비스 아키텍처 스타일

소프트웨어 프로세스의 논리적 설계 프로세스를 강조한 도메인 주도 설계 DDD 사상의 영향을 많이 받음

디커플링 스타일, bounded context..
bounded context 외부에 있는 것들(데이터베이스, 클래스 정의 등)과는 커플링 되지 않는다

하지만 커플링이 필요한 부분도 있을 것이다. 다만 마이크로서비스 아키텍처의 주요 목표는 디커플링인거고
bounded context의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링을 목표로 한다
(재사용보다 중복이 낫다)

* 토폴로지
    * API 레이어
    * 각 서비스들
        * 각각 데이터베이스를 가진다
* 분산
    * 마이크로서비스는 기본적으로 분산 아키텍처인데
    * 예전에는 모듈을 잘게 쪼개는게 어려웠다. 하지만 가상 머신, 컨테이너 기술이 발전하면서 운영, 리소스 측면에서 효율적으로 운영이 가능해졌다


### 17.4 bounded context

서비스마다 도메인이나 워크플로를 모델링
애플리케이션 작동에 필요한 모든 것이 포함되고, 다른곳에서 필요한 것들은 포함되지 않음 (클래스, 데이터베이스 등)
도메인 주도 설계의 논리적인 개념을 물리적으로 구현한 것이 마이크로서비스 아키텍처

* 세분도
    * 목적
        * 서비스를 무조건 잘게 나누는게 목적이 아니다. 마이크로서비스는 명칭 label이지 명세 description이 아니다
        * 도메인을 잘 적당히 나누어야한다
    * 트랜잭션
        * 분산 아키텍처에서 트랜잭션은 항상 문제가 된다. 이런 문제를 애초에 방지할 수 있는 설계가 바람직하다
    * 코레오그래피
        * 도메인 격리가 잘 되어도, 여러 도메인의 기능이 필요한 기능들은 반드시 생긴다
        * 통신 오버헤드, 운영 비용을 줄이기 위해 큰 서비스로 다시 뭉치는 것을 고려해야할 수도 있다
> 이렇게도 해보고 저렇게도 해보고, 반복하는 수밖에 없다

* 데이터 격리
    * bounded context 경계에 따라서 데이터도 격리. 데이터베이스를 분리
    * 분산된 데이터를 어떻게 가져오고, 복제하고 캐시할 수 있는지 구체적인 방안이 필요

### 17.5 API 레이어

여러 시스템 사이의 API 레이어가 존재
유저 인터페이스 혹은 다른 시스템의 호출

다양한 용도로 사용할 수는 있지만, API 레이어를 코레오그래피나 오케스트레이션 등의 로직이 포함되어선 안된다

### 17.6 운영 재사용

모니터링, 로킹, 서킷 브레이커 등의 기능들은 모든 서비스에 재활용되어야하는데 (커플링이 더 유리한데)

사이드카 패턴이 유용
> 옛날 얘기만 있는줄 알았는데 요즘에도 유용한 패턴도 나오네

공통 운영 관심사를 각 서비스마다 별도의 컴포넌트에 두고,
해당 팀이나 공유 인프라팀이 소유할 수 있도록 한다
팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 맡아 처리한다

서비스 메시를 구축하면 로깅, 모니터링 등의 관심사를 일원화 가능

공통 사이드카 컴포넌트는 일관된 운영 인터페이스를 제공

아키텍트는 마이크로서비스 아키텍처에 탄력성을 부여하는 수단으로 서비스 디스커버리를 사용
모든 요청이 서비스 디스커버리를 거치도록 하면 요청 수와 빈도를 확인 가능

> 모든 요청이 서비스 디스커버리를 경유하면 SPOF가 되고, 오히려 운영이 어려울 것 같다. 요청 수와 빈도는 다른식으로 해결하는게 좋지 않을까?
service mesh, istio, envoy 등에서 메트릭을 어떻게 제공하는지 궁금해졌다. 요즘은 어떻게 하는걸까?

### 17.7 프런트엔드

프런트엔드. 유저 인터페이스도
모놀리식 유저 인터페이스 vs 마이크로프런트엔드
로 나눌 수 있다

### 17.8 통신

동기? 비동기? 프토토콜?

* 프로토콜 인지 protocol-aware
    * 어떤 프로토콜로 통신해야할지 파악. HTTP, message, gRPC
* 이종 heterogeneous
    * 각 서비스마다 구현 기술 스택이 다를 수 있다. 폴리글랏 환경을 지원이 필요
* 상호 운용성 interoperability
    * 여러 서비스가 서로 호출하기 때문에, 정보를 주고받으며 서로 협력해야한다
* 복잡한 워크로드
    * 주문 -> 결제 -> 재고. flow를 생각해보자. 중간에 실패하면 어떻게 관리할 수 있을까?
    * 코레오그래피
        * 브로커 이벤트 기반의 아키텍처와 동일
        * 처음 호출된 서비스가 로컬 중재자가 되는 것. 다른 도메인 호출을 조정함
        * > 각 로컬 트랜잭션이 다른 서비스에서 로컬 트랜잭션을 트리거하는 도메인 이벤트를 게시합니다.
    * 오케스트레이션
        * 특정 서비스가 조정을 전담
        * > 오케스트레이터(객체)가 참가자에게 어떤 로컬 트랜잭션을 실행할지 알려줍니다.
    * 트랜잭션과 사가
        * 여러 서비스에 걸쳐 트랜잭션을 걸고 싶어한다면 **그렇게 하지마라!** 라고 말하고 싶다고 한다
        * 대신 컴포넌트 세분도를 바로 잡고 트랜잭션의 경계를 다시 생각해보라
            * 지나치게 세분화 한 것은 아닌가?
        * 트랜잭션 실패
            * 중재자는 이전에 처리했던 트랜잭션의 일부를 undo 해야한다
            * 보상 트랜잭션 compensating transaction
            * 구현 복잡. 디버깅 어려움. 작업량 2배

![image](assets/image27.png){width="800" height="400"}

![image](assets/image28.png){width="800" height="400"}



![image](assets/image29.png){width="800" height="600"}
