## 레이어드 아키텍처 스타일

- 단순하고 대중적이면서 비용도 적게 들어 모든 애플리케이션의 사실상 표준 아키텍처
- 묵시적 아키텍처 안티패턴, 우발적 아키텍처 안티패턴 등의 몇몇 아키텍처 안티패턴의 범주에 속한다.

### 10.1 토폴로지

레이어드 아키텍처에서 내부 컴포넌트는 논리적으로 수평한 레이더들로 구성되며, 각 레이어는 애플리케이션에서 주어진 역할을 수행한다.

- 레이어의 개수와 유형은 특별한 제한이 없지만, 일반적으로 프레젠테이션, 비즈니스, 퍼시스턴스, 데이터베이스의 4개 표준 레이어로 구성된다.

- 관심사의 분리 개념으로 아키텍처 내부의 역할 및 책임 모델을 효과적으로 구성할 수 있다.
- 레이어드 아키텍처는 기술 불한된 아키텍처이다.

### 10.2 레이어 격리

- 각 레이어는 상위 레이어에서 하위 레이어로 이동하므로 중간의 어떤 레이어도 건너뛸 수 없고 현재 레이어를 거쳐야 바로 그 다음 레이어로 나갈수 있다.
- 레이어 격리
  - 아키텍처 레이어에서 변경이 일어나도 다른 레이어에 있는 컴포넌트에 아무런 영향을 끼치지 않기에 레이어 간 계약은 불변임을 의미한다.
  - 각 레이어는 서로독립적이기 때문에 다른 레이어의 내부 작동 로직은 알지 못한다. (각 레이어간의 의존성을 줄이기 위함)

### 10.3 레이어 추가

- 내부적으로 폐쇄 레이어를 이용해 변경을 격리할 수 있지만 어떤 레이어는 개방하는것이 더 합리적이다.
- ex) 공통 비즈니스 기능이 구현된 객체를 직접 엑세스 하여 내부의 공유 객체를 갖다 쓸수 있께되면 지배/통제가 어려운 아키텍처 구조가 된다.
- 이럴때 공유 비즈니스 객체를 따로 분리해서 레이어로 만들게 되면 공유 비즈니스 객체를 사용하기 위해서는 비즈니스 레이어를 뚫고 가야한다.

아키텍처의 어느 레이어가 개방/폐쇄되어 있는지 정확히 문서화하여 소통하지 않으면 테스트,유지 보수,배포 작업이 아주 힘든, 단단한 커플링 되어 금방이라도 꺠질 듯한 아키텍처가 되어버릴 것이다.

### 10.4 기타 고려 사항

아키텍처 스타일을 정할때 재사용은 최소한으로, 객체 계층은 최대한 가볍게 맞추어 적절한 모듈성을 유지하는 것이 중요하다.
그래야 나중에 다른 아키텍처 스타일로 갈아타더라도 큰 어려움이 없다.

레이어드 아키텍처에서는 아키텍처 싱크홀 안티패턴을 조심해야한다. 요청한 레이어에서 다른 레이어로 이동할 때 각 레이어가 아무 비즈니스 로직도 처리하지 않고 그냥 통과 시키는 안티패턴을 말한다.
이런 흐름은 불필요한 객체 초기화 및 처리를 빈번하게 유발하고 쓸데없이 메모리를 소모하며 성능에도 부정적인 영향을 끼친다.

아키텍처 싱크홀 안티패턴에 해당하는 시나리오가 전무한 레이어드 아키텍처는 전무하겠지만 80대 20 정도의 비율이라면 그런대로 괜찮은 수준이다.

### 10.5 왜 이 아키텍처 스타일을 사용하는가

익숙하고 복잡하지 않기 떄문에 아키텍트가 아직 비즈니스 니즈와 요구사항을 분석하는 중이고 어떤 아키텍처 스타일이 최선인지 불확실한 경우에도 나쁘지 않은 선택이다.
