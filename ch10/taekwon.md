# CHAPTER 10

# Overview

레이어드 아키텍처는 가장 흔한 아키텍처 스타일 중 하나이다. 단순하고 대중적이면서 비용도 적게 들어 모든 애플리케이션의 사실상 표준 아키텍처이다.

그러나 레이어드 아키텍처 스타일은 `묵시적 아키텍처 안티패턴`, `우발적 아키텍처 안티패턴` 등의 몇몇 아키텍처 안티패턴의 범주에 속한다.

## 토폴로지

레이어드 아키텍처에서 내부 컴포넌트는 논리적으로 수평한 레이어들로 구성되며, 각 레이어는 애플리케이션에서(프레젠테이션 로직, 비즈니스 로직 등의) 주어진 역할을 수행한다.

레이어의 개수와 유형은 특별한 제한이 없지만, 일반적으로 `프레젠테이션` `비즈니스` `퍼시스턴스` `데이터베이스` 4개의 표준 레이어로 구성된다. 또한 이를 `배포` 관점에서의 다양한 토폴로지로 변형이 가능하다.

레이어드 아키텍처 스타일의 각 레이어는 아키텍처 내부에서 특정한 역할과 임무를 수행하며, 각 레이어는 주어진 비즈니스 요청을 충족하는 데 필요한 업무 위주로 추상화되어 있다. 예를 들어, **프레젠테이션 레이어는 고객 데이터를 조회하는 방법은 알 필요가 없고 그럴 이유도 없다**.

이러한 `관심사의 분리` 개념 덕분에 레이어드 아키텍처 스타일은 아키텍처 내부의 역할 및 책임 모델을 효과적으로 구성할 수 있으며, 특정 레이어에 소속된 컴포넌트는 역할 범위가 한정되며 그 레이어에 알맞은 로직만을 처리한다.

레이어드 아키텍처는 기술 분할된 아키텍처로 개발자 본인의 기술 역량을 도메인의 기술적인 부분에 집중시킬 수 있지만, 반대로 전체적인 변화에 대한 민첩성이 떨어지는 트레이드오프가 있다.

## 레이어 격리

레이어드 아키텍처의 각 레이어는 `폐쇄` 또는 `개방` 상태이다. 폐쇄 레이어란 요청이 상위 레이어에서 하위 레이어로 이동하므로 중간의 어떤 레이어도 건너뛸 수 없고 현재 레이어를 거쳐야 바로 그 다음 레이어로 나아갈 수 있다는 뜻이다.

하지만 단순 조회 요청이라면 불필요한 레이어를 건너뛰고 프레젠테이션 레이어가 데이터베이스를 직접 액세스하는 편이 더 빠르고 간편한 경우가 있으며, 이때는 레이어간의 개방상태가 필요하다.

중요한 것은 레이어 격리는 어느 아키텍처 레이어에서 변경이 일어나도 다른 레이어에 있는 컴포넌트에 아무런 영향을 끼치지 않기에 레이어 간 계약은 불변임을 의미하며, 레이어 격리를 지원하려면 레이어가 반드시 폐쇄되어있어야 한다.

예를 들어 프레젠테이션 레이어에서 퍼시스턴스 레이어에 직접 접근이 가능하다면 퍼시스턴스 레이어의 변경이 프레젠테이션 레이어까지 영향을 주게 되며, 이는 상호 의존도가 높아져서 단단히 커플링된 애플리케이션이 될 것이다.

## 레이어 추가

아키텍처 내부적으로 폐쇄 레이어를 이용해 변경을 격리할 수 있지만, 어떤 레이어는 개방하는 것이 더 합리적인 경우가 있다.

예를 들어 공통 비즈니스 기능이 구현된 객체를 구현하여 공유하는 경우 폐쇄 상황에선 프레젠테이션 레이어가 공유 비즈니스 객체를 직접 액세스할 수 없다. 그러나 이를 새로운 서비스 레이어로 아키텍처에 추가하여 개방 레이어로 설계하는 경우 비즈니스 레이어는 이 레이어를 액세스 하거나 건너 뛰어 다음 레이어인 퍼시스턴스 레이어로 향할 수 있다.

이러한 개념을 잘 활용하여 아키텍처 레이어 간 관계와 요청 흐름을 정의할 때 유용하게 사용이 가능하며, 어느 레이어가 개방/폐쇄되어 있는지(왜 그런지)를 정홗히 문서화 하여 소통하지 않으면 테스트, 유지보수, 배포작업이 아주 힘든, 단단히 커플링되어 금방이라도 깨질 듯한 아키텍처가 될 것이다.

## 기타 고려 사항

재사용은 최소한으로, 객체 계층은 최대한 가볍게 맞추어 적절한 모듈성을 유지하는 것이 중요하다. 그래야 나중에 다른 아키텍처 스타일로 갈아타더라도 큰 어려움이 없다.

레이어드 아키텍처에서는 `아키텍처 싱크홀` 안티패턴을 조심해야 한다. 요청이 한 레이어에서 다른 레이어로 이동할 때 각 레이어가 아무 ㅈ비즈니스 로직도 처리하지 않고 그냥 통과시키는 안티패턴을 말한다.

이런 흐름은 불필요한 객체 초기화 및 처리를 빈번하게 유발하고 쓸데없이 메모리를 소모하여 성능에도 부정적인 영향을 끼친다. 이러한 싱크홀의 비중이 80%이상이 나올 경우 해당 도메인에 레이어드 아키텍처는 적합한 아키텍처 스타일이 아니라는 증거이기도 하다.

이러한 안티패턴을 해결하는 또 다른 방법은 아키텍처의 모든 레이어를 개발하는 것이다. 그러나 이는 아티켁처상 변경 관리의 어려움이 가중되는 트레이드오프가 있음을 인식해야 한다.

## 왜 이 아키텍처 스타일을 사용하는가

레이어드 아키텍러는 작고 단순한 애플리케이션이나 웹사이트에 알맞은 아키텍처 스타일입다. 특히, 처음 구축을 시작할 떄, 예산과 일정이 빠듯한 경우 출발점으로 괜찮은 선택이다.

그러나 레이어드 아키텍처 기반의 애플리케이션은 규모가 커질수록 유지 보수성, 민첩성, 시험성, 배포성 같은 아키텍처 특성이 점점 나빠지게 된다. 따라서 레이어드 아키텍처를 사용한 대규모 애플리케이션이나 시스템은 다른 더 모듈러한 아키텍처 스타일이 더 잘 맞는다.

## 아키텍처 특성 등급

아키텍처 특성 등급에 따라 레이어드 아키텍처를 봤을때 아래와 같다.

- 전체 비용 단순성 : 주요 강점으로 복잡도가 낮고, 구조가 단순해서 알기 쉬우며 구축 비용도 적다
- 배포성과 시험성 : 배포를 하려면 절차가 까다롭고 리스크가 높으며 자주 배포할 수 없다.
- 시험성  : 그나마 모킹 또는 스터빙을 할 수 있어 전체 테스트 공수는 덜 든다.
- 신뢰성 : 분산 아키텍처의 일반적인 네트워크 트래픽, 대역폭, 레이턴시 문제는 덜 하다.
- 탄력성, 확장성 : 확장을 위해 멀티스레딩, 내부 메시징등의 갖가지 병렬 처리 기법이 동원된다.
- 성능 : 병렬 처리가 거의 안 되고, 폐쇄적인 구조, 싱크홀 안티패턴으로 고성능 시스템과 거리가 있다.
- 내고장성 : 어느 한 작은 파트의 문제점이 전체적으로 영향을 받고 충돌이 발생한다.
- 가용성 : 모놀리식 애플리케이션이 겪는 MTTR(평균수리시간)으로 가용성도 영향이 있다.
