# CHAPTER 1

# Overview

소프트웨어 아키텍트는 다른 직업에 비해 직업경로가 분명하지 않다.

- 직업 자체에 대한 명확한 정의가 아직도 없다.
- 방대한 분야를 포괄하며 업무 범위도 계속 넓어지고 있다.
- 워낙빠르게 발전하는 분야이며, 끊임없이 변한다.
- 관련 자료는 대부분 역사적인 연관성을 강조한다.

아키텍처란 예술과 마찬가지로 `context` 로서만 이해할 수 있다. 즉, 당시 환경에 기인한 결과물이다.

# 1.1 소프트웨어 아키텍처란?

소프트웨어 아키텍처를 바라보는 한 가지 방법으로, 시스템이 지원해야 할 `~성`  으로 끝나는 `아키텍처 특성` 과 `아키텍처 결정` , `설계 원칙` 과 시스템의 `구조` 로 구성된다.

시스템의 구조란 시스템이 구현된 아키텍처의 종류(`MSA`, `layered`  등)를 말한다. 하지만 구조만으로는 아키텍처에 대한 전체적인 설명이 부족하다. 아키텍처를 완전히 이해하기 위해선 남은 구성을 알아야 한다.

아키텍처 특성은 소프트웨어 아키텍처를 다른 관점으로 바라본 것으로 시스템의 기능과 직교하는 `시스템의 성공 기준` 을 결정한다.

아키텍처 결정은 시스템 구축에 필요한 규칙의 정의(`제약조건` )즉, 개발자가 해도 되는 것과 하지 말아야할 것을 알려준다.(레이어 간의 규칙 등)

다만  어떤 상황에서 제약조건으로 인해 아키텍처 결정을 구현할 수 없다면 해당 규칙이나 결정은 `변형` 을 통해 깨뜨릴 수 있다.

마지막 요소인 설계 원칙은 `가이드라인` 으로 적합한 통신 프로토콜 등을 선택할 수 있도록 권장하는 방법에 대한 가이드를 제공하는 것이다.(서비스 간 통신은 비동기 메시징을 활용한다고 기술)

# 1.2 아키텍트에 대한 기대치

아키텍트에게 바라는 핵심적인 요구사항은 아래와 같다.

- 아키텍처 결정을 내린다.
- 아키텍처를 지속적으로 분석한다.
- 최신 트랜드를 계속 유지한다.
- 아키텍처 결정의 컴플라이언스를 보장한다.
- 다양한 기술과 경험에 노출된다.
- 비즈니스 도메인 지식을 보유한다.
- 대인 관계 기술이 뛰어나다.
- 정치를 이해하고 처세를 잘한다.

## 1.2.1 아키텍처 결정을 내린다.

아키텍트는 기술 선택을 가이드하는 사람이지, 정해주는 사람이 아니다. 특정 기술에 대한 결정은 개발팀 스스로가 선택을 할 수 있게 결정이나 설계 원칙을 가이드 한것이 아니라 기술 결정을 한 것이다.

효과적인 아키텍처 결정을 하려면 아키텍트 자신이 내린 결정이 개발팀 스스로의 기술 결정에 도움이 되는지, 아니면 대신 선택해주는게 더 나을지 자문해봐야 한다.

즉, 아키텍트는 `확장성` `성능` `가용성` 등의 특성을 지키기 위해 특정한 기술을 결정해야 할 경우가 생기는데, 이런 경우 그 기술을 지정한 행위자체를 아키텍처 결정이라 부를 수 있다.(이 경계선을 긋느라 진땀을 뺌)

## 1.2.2 아키텍처를 지속적으로 분석한다.

이를테면 3년 이전에 정의한 아키텍처가 지금도 얼마나 현실성 있는지 지속적인 평가가 필요하다.

대부분의 아키텍처는 이를 지키지 못해 쇠락하는 야상을 보이며, 특히 성능, 가용성, 확장성 등의 필수 아키텍처 특성에 영향을 미치는 코드를 개발자가 작성하거나 설계를 벼경할 때 이런 증상이 나타난다.

## 1.2.3 최신 트렌드를 계속 따라간다.

아키텍트는 최신 기술과 업계 트렌드를 따라가야 하는, 한층 더 중요한 요구사항을 달성해야 한다.

아키텍트가 결정한 것들은 대개 오래 지속되고 바꾸기도 어렵기에 핵심 트렌드를 이해하고 계속 좇아갈 수 있어야 미래를 대비하고 올바른 결정이 가능하다.

## 1.2.4 아키텍처 결정의 컴플라이언스를 보장한다.

컴플라이언스 보장이란, 아키텍트가 정의하고 문서화하여 전달한 아키텍처 결정과 설계원칙들을 개발팀이 제대로 준수하고 잇는지 지속적으로 확인한다는 뜻이다.

아키텍트가 결정한 데에는 `변경을 다스리겠다` 는 중요한 의도가 있으며, 개발자가 아키텍처 결정을 준수하지 않으면 아키텍처는 필요한 아키텍처 특성(`~성`)을 준수할 수 없게 되며, 기대한 것처럼 동작하기 어렵다.

## 1.2.5 다양한 기술과 경험에 노출된다.

아키텍트가 모든 프레임워크, 플랫폼, 언어에 통달해야 할 필요는 없지만, 적어도 다양한 기술을 거리낌 없이 쓸 줄은 알아야 한다.

그러기 위해 자신이 가장 익숙한 영역을 넓혀가는 것이 가장 좋다. 예를 들어, 아키텍트는 한 가지 캐시 제품에 정통한 전문가가 되려고 하기 보다 10가지 캐시 제품을 어느 정도 다룰 줄 알고 각각의 trade-off를 아는게 더 중요하다.

## 1.2.6 비즈니스 도메인 지식을 보유한다.

비즈니스 도메인 지식이 없으면 비즈니스의 문제점, 목표, 요구사항을 이해하기 어렵고, 따라서 요구사항을 수용할 만한 효율적인 아키텍처 설계도 어렵다.

가장 성공적인 아키텍트는 폭넓은 실무 기술지식과 더불어 특정 도메인에 깊이 있는 지식을 보유한 사람들이다.

## 1.2.7 대인 관계 기술이 뛰어나다.

아키텍트는 팀워크, 조정, 리더십을 포함한 대인 관계 기술이 뛰어나야 한다. 개발팀을 기술적으로 이끌기만 하는 사람이 아닌, 개발팀을 리드해서 아키텍처를 구현하는 사람이므로 직책 또는 역할과 상관없이 리더십 스킬이 필요하다.

## 1.2.8 정치를 이해하고 처세를 잘한다.

아키텍트가 내린 거의 모든 결정은 사람들의 반발에 부딛히게 마련이다. 그래도 아키텍트는 회사에서 정치를 잘하면서 대부분의 결정을 사람들이 수용하도록 기본적인 협성 기술을 발휘해야 한다.

최종적으로 폭넓고 중요한 결정을 내리는 아키텍트 수준에 이르면 거의 모든 결정을 정당화 하고 반대 세력에 맞서 싸울 준비를 갖추어야 한다.

# 1.3 아키텍처의 교차점 그리고…

아키텍처의 범위는 지난 10년 동안 점점 더 많은 책임과 관점을 아우르는 방향으로 확대 되었다.

이제 MSA에서는 예전에 순전히 운영 관심사였던 부문을 자유롭게 넘나들 수 있게 되었다. 예를 들어

과거에는 아키텍처에 탄력적 확장 기능을 구현하기 위해 고통스러운 과정이 수반됐지만, 아키텍트와 데브옵스간의 소통을 통해 수월하게 처리가 가능하다.

## 1.3.1 엔지니어링 프랙티스

엔지니어링 프랙티스와 소프트웨어 개발 프로세스는 구분해야 한다.

프로세스는 팀을 어떻게 구성하고 관리할지, 회의는 어떻게 하고 워크플로 조직은 어떻게 운영할지 등 사람을 조직하고 상호작용하는 총체적인 기법입니다.

반면, 소프트웨어 엔지니어링 프랙티스는 프로세스와 무관하게 가시적이고 반복 가능한 혜택을 주는 실천론이다.(지속적 통합, 자동화 테스팅 등)

아키텍처 스타일과 엔지니어링 프랙티스는 공생 관계를 형성하도록 해야한다. 예를 들어 MSA는 머신 프로비저닝과 자동화 테스팅/배포 등 많은 것들을 전제로 한다.

# 1.4 소프트웨어 아키텍처 법칙

- 제 1법칙
  - 소프트웨어 아키텍처의 모든 것은 다 트레이드 오프다. 모든 결정은 여러 가지 상충되는 팩터들을 전부 다 고려해야 한다.
- 제 2법칙
  - 어떻게 보다 왜 가 더 중요하다.
