# 마이크로커널 아키텍처 스타일

## 토폴로지

- 코어 시스템과 플러그인 컴포넌트라는 두가지 아키텍처 요소로 구성
- 코어 시스템 : 시스템을 실행시키는 데 필요한 최소한의 기능
    - 전자제품 예시
    - 각 전자제품에 해당하는 로직을 코어 시스템에서 실행 가능하도록 일반화한 플러그인에 담음
    - 코어 시스템의 프레젠테이션 레이어는 코어 시스템에 내장하거나 별도 UI로 구현
- 플러그인 컴포넌트 : 특수한 처리 로직, 부가 기능, 코어 시스템을 개선/확장하기 위한 커스텀 코드가 구현된 스탠드 얼론 컴포넌트
    - 변동성이 매우 큰 코드를 분리 → 유지보수성, 시험성 높아짐
    - 상호 독립적
    - 플러그인 컴포넌트와 코어 시스템은 점대점 통신을 한다.
    - 플러그인 컴포넌트는 관리하기 편하지만 삭제/추가 시에 전체 애플리케이션을 재배포해야 한다.
    - 플러그인과의 통신은 REST로도 구현 가능
        - 하지만 모든 요청이 코어 시스템을 거쳐야 하므로 모놀리식 아키텍처
        - 장점 : 전체 컴포넌트의 커플링이 낮아져 확장성과 처리량이 개선. 런타임 수정 가능. 비동기 통신 가능.
        - 단점 : 원격 플러그인에 접속하려면 모놀리식 → 분산 아키텍처로 수정해야 한다. 비용과 복잡도가 높아진다.
    - 플러그인은 코어 시스템의 DB에 접근할 일이 거의 없으며 필요한 경우 자체 데이터 저장소를 둔다.
        - 외장(인메모리, 임베디드 DB) or 내장

## 레지스트리

- 코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알아야 한다
    - 레지스트리 이용
- 레지스트리는 플러그인 명칭, 데이터 계약, 세부 원격 액세스 프로토콜 등 플러그인에 대한 정보를 가진다
    - 점대점, 메시징, REST

## 계약

- 플러그인 컴포넌트와 코어 시스템 간의 계약은 플러그인 컴포넌트의 도메인 단위로 표준화 되어 있다
- 플러그인 컴포넌트가 수행하는 기능 및 입출력 데이터는 계약에 명시

## 실제 용례

- 이클립스 IDE, PMD, 지라, 젠킨스, 크롬, 파이어폭스
- 보험금 청구 프로세스
    - 크고 복잡한 규칙 엔진 사용
    - 규칙 엔진이 진흙 잡탕이 되어 다른 규칙들이 연쇄적으로 영향을 받거나 하나의 수정에 큰 검토가 필요할 수 있다
    - 마이크로커널 아키텍처 패턴을 사용하여 관할 구역별 보험금 청구 규칙을 플러그인 컴포넌트로 분리
- 세무 신고 소프트웨어에도 양식을 플러그인 컴포넌트화 할 수 있다

## 아키텍처 특성 등급

- 모놀리식과 유사
    - 강점 : 단순성, 전체 비용
    - 단점 : 탄력성, 내고장성, 확장성
    - 퀀텀 = 1
- 도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍처 스타일
    - 위치나 클라이언트에 따라 설정이 달라지는 문제는 이 아키텍처가 제격
- 기능을 독립적인 플러그인 컴포넌트로 분리할 수 있으므로 시험성, 배포성, 신뢰성은 평균
- 독립적인 자기 완비형 플러그인 컴포넌트를 통해 기능을 추가, 삭제, 변경할 수 있고 애플리케이션을 개선/확장하는 작업이 비교적 용이 → 모듈성 평균 이상