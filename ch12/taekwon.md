# CHAPTER 12

# Overview

마이크로커널 아키텍처(`플러그인 아키텍처` )는 단일 모놀리식 배포 단위로 패키징해서 다운로드 및 설치가 가능하며, 보통 고객 사이트에서 서드파티 제품으로 설치되는 제품기반 애플리케이션에 적합하며, 비제품 고객 비즈니스 애플리케이션에서도 많이 사용된다.

## 토폴로지

마이크로커널 아키텍처 스타일은 `코어 시스템` 과 `플러그인 컴포넌트` 라는 두 가지 아키텍처 요소로 구성된 비교적 단순한 모놀리식 아키텍처이다.

애플리케이션 로직은 독립적인 플러그인 컴포넌트와 기본 코어 시스템에 골고루 분산되어 확장성, 적응성, 앺플리케이션 기능 분리, 커스텀 처리 등을 수행한다.

### 코어 시스템

코어 시스템은 시스템을 실행시키는 데 필요한 최소한의 기능으로 정의한다. IDE가 가장 좋은 예이다. 기본적인 텍스트 에디터에 플러그인을 추가해야 비로소 쓸 만한 제품이 된다.

그러나 다른 관점에서 보면, 코어 시스템은 커스텀 처리가 거의/전혀 필요 없는, 애플리케이션을 관통하는 `정상 경로` 라고 정의할 수 있다. 코어 시스템의 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하면 확장성, 유지보수성은 물론 시험성 또한 좋아진다.

클라이언트에 종속된 코드를 순환 복잡도가 높은 코어시스템에 두는 대신 각, 클라이언트마다 플러그인 컴포넌트를 따로 만들면 더 효율적이다. 이렇게 개별 클라이언트 플러그인 컴포넌트를 끼우면

나머지 처리 흐름과 무관한 로직을 따로 떼어낼 수 있고 차후 확장도 가능하다.

코어 시스템은 규모와 복잡도에 따라 레이어드 아키텍처나 모듈러 모놀리스로 구현할 수 있다. 경우에 따라 코어 시스템을 별도 배포하는 도메인 서비스로 나누어 서비스별 도메인에 특정한 플러그인 컴포넌트를 둘 수도 있다.

### 플러그인 컴포넌트

플러그인 컴포넌트는 코어 시스템을 개선/확장하기 위한 스탠드얼론 컴포넌트로 변동성이 매우 큰 코드를 분리하여 애플리케이션 내부의 유지보수성, 시험성을 높인다. 이상적 플러그인 컴포넌트는 상호 독립적이며 의존성이 없다.

컴포넌트와 코어 시스템은 일반적으로 `점대점` 통신을 한다. 즉, 코어 시스템에 플러그인을 연결하는 `파이프`는 대부분 플러그인 컴포넌트의 진입점 클래스를 호출하는 메서드 코드이다.

플러그인 컴포넌트는 `컴파일 기반 / 런타임 기반` 으로 만들 수 있으며, 런타임 플러그인의 경우 재배포 없이 추가/삭제가 가능하다. 컴파일 기반의 플러그인은 관리하기는 편하지만 변경, 추가 삭제 시 전체 모놀리식 애플리케이션의 재배포가 필요하다.

플러긘 컴포넌트가 반드시 코어 시스템과 점대점 통신을 해야 하는 것은 아니다. 각 플러그인을 스탠드 얼론 서비스로 만들어 `REST` 혹은 `메시징` 등 다른 방법으로 기능을 호출하는 방법도 이따. 언뜻 보기에 확장성을 개선하는 좋은 방법 같지만, 이 토폴로지는 코어 시스템이 모놀리식이므로 여전히 단일 아키텍처 퀀텀 즉, 모든 요청이 무조건 코어 시스템을 거쳐 각 플러그인 서비스로 흘러가는 구조이다.

플러그인 컴포넌트를 개별 서비스로 구현해 원격 액세스 하는 방법은 전체 컴포넌트의 커플링이 낮아져 확장성과 처리량이 개선되며, 특수한 프레임워크(직소, 프리즘 등)없이도 런타임 변경이 가능한 장점이 있다.

하지만 장점이 있으면 단점이 있듯 원격 플러그인에 접속하려면 마이크로커널 아키텍처를 모놀리식이 아닌 `분산 아키텍처` 로 바꿔야 하는데, 대부분의 서드파티 온프렘 제품은 그렇게 구현/배포 하기 쉽지 않고 전반적으로 복잡도와 비용이 높아져 전체 배포 토폴로지가 상당히 난해해 진다.

플러그인 컴포넌트가 중앙 공유 데이터베이스에 직접 접속할 일은 거의 없으며, 외려 코어 시스템이 그역할을 담당하며, 필요한 데이터를 모두 가져와 각 플러그인에 전달한다. 이는 디커플링에 제일 큰 이유가 있으며, 데이터베이스를 변경하는 행위는 코어 시스템에만 영향을 미치고 플로그인 컴포넌트에는 옇양이 없기에 자기만 액세스 가능한 데이터 저장소를 따로 가질 수 있다.

## 레지스트리

코어 시스템은 ㅓ떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알고 있어야 한다. 가장 일반적인 구현 방법은 `플러그인 레지스트리` 를 경유하는 것이다.

이 레지스트리에는 플로그인의 명칭, 데이터 계약, 세부 원격 액세스 프로토콜 등 각 플러그인 모듈에 관한 정보가 있다.

레지스트리는 코어 시스템이 소유한 내부 맵 구조처럼 단순할 수 도 있고, 아파치 주키퍼 및 콘솔 처럼 외부 배포된 시스템에 내장된 복잡한 형태일 수도 있다.

## 계약

플러그인 컴포넌트와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화되어 있고, 플러그인 컴포넌트가 수행하는 기능 및 입출력 데이터는 계약에 명시되어 있다.

서드파티 회사가 개발한 플러그인 컴포넌트의 계약을 마음대로 바꿀 수 없을 때에는 보통 커스텀 계약을 사용하며, 일반적으로 코어 시스템이 각 플러그인별 코드를 필요로 하지 않도록 플러그인 계약과 우리가 정한 표준 계약 간의 어댑터를 만든다.

## 실제 용례

이클립스 IDE, PMD, 지라, 젠킨스 등 많은 소프트웨어 개발/릴리스 도구가 마이크로 커널 아키텍처를 사용해서 개발 되었다.

크롬, 파이어폭스 같은 인터넷 웹 브라우저도 마이크로커널 아키텍처를 응용한 제품으로, 각종 뷰어와 플러그인을 장착하면 코어 시스템에 해당하는 기본 브라우저에 없는 부가 기능을 덧붙일 수 있다.

제품 기반의 소프트웨어 역시 용례는 무궁무진하지만, 마이크로 커널 아키텍처는 대규모 비즈니스 애플리케이션에도 적용할 수 있다. 보험금 청구건을 처리하는 보험 회사 시스템 혹은 세무 신고 소프트웨어등이 그 예이다.

## 아키텍처 특성 등급

마이크로커널 아키텍처도 레이어드 아키텍처처럼 단순성과 전체 비용은 주요 강점이다. 반면, 고질적인 모놀리식 배포 탓에 탄력성, 내고장성, 확장성이 문제가 될 때가 많다. 또한 모든 요청이 코어 시스템을 통해 유입되어 독립적인 플러그인 컴포넌트로 흘러가므로 퀀텀은 언제나 1이다.

마이크로커널 아키텍처는 도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍처 스타일이다. 대부분 기술 분할되지만, 도메인 분할 역시 강력한 도메인 대 아키텍처 동형성을 통해 실현된다.

기능을 독립적인 플러그인 컴포넌트로 분리할 수 있으므로 시험성, 배포성, 신뢰성은 평균 이상이다.

모듈성또한 평균 이상으로 마이크로커널 아키텍처는 독립적인 자가 완비형 플러그인 컴포넌트를 통해 기능을 추가, 삭제, 변경할 수 있고, 덕분에 애플리케이션을 개선/확장하는 작업이 비교적 용이하다.
