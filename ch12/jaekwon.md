## 12장. 마이크로커널 아키텍처 스타일

= 플러그인 아키텍처

* 코어 시스템
* 플러그인 컴포넌트

Intellij는 단순한 텍스트 데이터. 여기에 각종 플러그인을 설치해서 더 풍부하게 사용할 수 있다


규모와 복잡도에 따라서 레이어드 아키텍처(기술분할)나 모듈러 모놀리스(도메인 분할)로 구현 가능
![image](assets/image16.png){width="800" height="500"}


그리고 각종 컴포넌트들 역시 마이크로커널 아키텍처 스타일로 구성할 수 있다
![image](assets/image17.png){width="800" height="800"}


변동성이 매우 큰 코드를 분리하여 코어 시스템의 유지보수성, 시험성을 높인다
플러그인 컴포넌트끼리는 독립적. 서로 영향 X

플러그인과 코어는 점대점 point to point 통신
* 플러그인-코어 연결 방법
  * 보통은 진입점 클래스를 호출하는 메서드나 함수 코드
    * 컴파일 기반
      * 배포 필요
    * 런타임 기반
      * 배포 불필요
      * 자바 OSGi, 펜로즈, 직소, 프리즘
  * 공유 라이브러리로 제공
  * 각 플러그인 자체를 스탠드얼론 서비스로 만들어서 REST, 메시지로 통신. 원격 엑세스
    * 이 경우에도 모든 요청은 코어 시스템을 거침. 단일 퀀텀
    * (장점) 전체 컴포넌트의 확장성 향상, 처리량 개선, 코어와 상관없이 변경 가능
    * (단점) 모놀리식 -> 분산 아키텍처로 변환. 복잡도와 비용 증가. REST API가 실패한다면?


플러그인 컴포넌트에서 코어 시스템의 데이터베이스를 직접 접근 X
각자 데이터베이스를 둘수도 있다

* 레지스트리
  * 플러그인 레지스트리, 마켓플레이스
* 계약
  * 플러그인-코어 간의 인터페이스, 스펙 정의
  * 플러그인이 수행하는 기능 및 입출력 데이터
  * XML, JSON 또는 객체로 구현되어 플러그인-코어가 주고받음
* 사용 사례
  * 이클립스
  * PMD
  * 지라
  * 젠킨스
  * 크롬
  * 파이어폭스

보험금 청구 서비스
각 주마다 보험금 룰이 다르다
이때 보험금 청구 규칙을 별도의 스탠드얼론 플러그인 컴포넌트로 보관. 그러면 다른 시스템에 영향을 주지 않고 특정 관할의 룰을 추가,삭제,변경 할 수 있다
이때 코어 시스템이 영향 받지 않는다


![image](assets/image18.png){width="800" height="600"}


* 장점
  * 도메인 분할, 기술 분할 모두 가능
  * 잘 분할한다면 변경분에 대한 전체 테스트 범위, 배포 리스크가 줄어든다
* 단점
  * 모놀리식 배포 탓에 탄력성, 내고장성, 확장성이 떨어짐
