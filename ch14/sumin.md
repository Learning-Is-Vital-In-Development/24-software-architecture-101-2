---
marp: true
---
# 이벤트 기반 아키텍처 스타일
* 비동기 분산 아키텍처 스타일
* 요청 기반 모델
    * 요청을 받아 DB에서 정보를 조회/수정하는 등의 작업을 수행으로 요청처리
---
* 중재자 토폴로지, 브로커 토폴로지
    * 중재자 토폴로지 : 이벤트 처리 워크플로를 제어할 경우
    * 브로커 토폴로지 : 신속한 응답과 동적인 이벤트 처리 제어가 필요할떄
* 브로커 토폴로지
    * 중앙에 이벤트 중재자가 없다는 점에서 중재자 토폴로지와 다르다.
    * 경량 메시지 브로커를 통해 브로드캐스팅
    * 비교적 이벤트 처리 흐름이 단순하고 굳이 중앙에서 이벤트를 조정할 필요가 없을때 유용
    * 시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트
    * 파이어 앤드 포켓 방식으로 비동기 브로드캐스팅
    * 다른 이벤트 프로세서의 관심여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는게 항상 바람직
    * 단점
        * 시작이벤트와 연관된 전체 워크플로를 제어할수가 없다
        * 에러처리 어렵다. ( 에러가 나든 안나든 다른 모든 프로세스는 그냥 알아서 작동)
        * 비지니스 트랜잭션을 재시작하는 기능도 지원되지 않음
        * 데이터 비일관성
---
* 중재자 토포로지
    * 시작 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서
    * 브로커와의 차이점
        * 이벤트 큐를 거쳐 이벤트 중재자로 전달된다는 점
        * 이벤트 프로세서가 다른 프로세서에게 자신이 한일을 알리지 않는다.
    * 특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재하므로 단일장애점을 줄이고 전체 처리량과 성능을 높일 수 있다.
    * Apache Camel, Mule EBS,오라클 BPEL 프로세스 관리자, 아파치 ODE
    * 단점
        * 이벤트 프로세서가 커플링됨
        * 확장성이 낮음
        * 성능이 낮음
        * 내고장성이 좋지 않음
---
* 비동기 통신
    * 유저가 굳이 어떤 정보를 돌려받을 필요가 없다면 기다리게 할 이유가 없다.
    * 응답성 : 어떤 액션이 접수되어 곧 처리될 것이라는 사실을 유저에게 알리기
    * 성능 : 종단간 프로세스가 더 빨리 수행되게끔 만드는것
    * 에러 처리가 쉽지 않아 이벤트 기반 시스템의 복접도가 가중된다.

* 비동기 통신 : 에러처리
    * 워크플로 이벤트 패턴 : 시스템을 응답성에 영향을 미치지 않고 탄력적으로 에러를 처리할 수 있게 만드는 패턴
    * 에러를 워크플로 프로세스에 위임하고 이벤트 큐의 다음 메세지로 넘어감
        * 문제 파악하고 원래 큐로 돌려보냄. 재처리 시도
        * 문제점 파악 못하면 대시보드로.
        * 메세지 순서 유지가 어려움
---
* 비동기 통신 : 데이터 소실 방지
    * 동기 전송, 퍼시스턴트 메시지 큐
        * 퍼시스턴트 메시지 큐 : 전달 보장이 지원. 메시지 브로커가 메시지를 수신하면 신속한 조회를 위해 메모리에 저장하는 동시에 물리적 데이터 저장소에도 메시지를 저장.
        * 동기 전송 : 브로커가 메시지를 저장했다고 확인응답을 줄때까지 메시지 프로듀서를 차단하여 기다리게 한다.
    * 클라이언트 확인응답모드
    * DB의 ACID 트랜잭션 커밋으로 해결
* 브로드캐스팅 : 여러 이벤트 프로세서를 가장 높은 수준으로 디커플링하는 수단

---
* 요청-응답 : 동기 통신
* 헤더에 correlation ID 추가
* 응답 큐에 임시큐를 두고 요청-응답 메시징 구현하는 방법 -> 매번 임시 큐 삭제해야함

* 요청 기반보다 좋은 점
    * 동적인 유저 컨텐츠의 응답성이 좋음
    * 확장성, 탄력성이 우수
    * 민첩성과 변화 관리가 우수
    * 적응성과 확장성이 뛰어남
    * 응답성과 성능이 좋음
    * 실시간 의사 결정이 가능함
    * 상황 인지에 따른 반응성이 좋음
* 장단점
    * 최종 일관성만 지원됨
    * 처리 흐름을 제어하기 곤란함
    * 이벤트 흐름의 결과를 예측하기 어려움
    * 테스팅, 디버킹이 어려움




