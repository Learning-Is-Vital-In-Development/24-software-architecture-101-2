---
marp: true
---

# Ch8. 컴포넌트 기반 사고

---

## 8.1 컴포넌트 범위

### 컴포넌트의 예시

1. 라이브러리
- 호출부 코드와 동일한 메모리 주소에서 실행
- 해당 언어의 함수 호출 메커니즘을 이용해 통신
- 일반적으로 컴파일 타임에 의존
  - 단, DLL 같은 경우는 예외

---

2. 서비스
- 자신의 주소 공간에서 실행
  - TCP/IP 같은 저수준 네트워크 프로토콜,
  - REST, 메시지 큐 같은 고수준 포맷을 통해 통신
  - MSA에서는 배포 가능한 독립적인 단위 형성

**아키텍트가 반드시 컴포넌트를 사용해야 하는 것은 아니지만,
컴포넌트는 아키텍트의 근본적인 모듈성을 구성하는 요소**

---

## 8.2 아키텍트 역할

### 8.2.1 아키텍처 분할

최상위 분할
- 레이어 기반의 분할 : 레이어드 아키텍처
- 도메인에 따라 분할 : 모듈러 모놀리스
- 기술적 역할에 따라 분할 : 프레젠테이션 / 컨트롤러 / 서비스 / 퍼시스턴스

---

### 콘웨이의 법칙

시스템을 설계하는 조직은 그 고직의 소통 구조를 그대로 옮겨 놓은 듯한 설계도를 그릴 수 밖에 없다.

Q 적용 질문 : 기술적 역할에 따른 분할 vs 도메인 기반 분할 -> 어느 쪽을 더 선호하는가? 그 이유는?

---

### 도메인 분할

장점
- 세부 구현보다 비즈니스 기능에 더 가깝게 모델링이 된다.
- 역 콘웨이 전략을 활용하여 도메인별 다목적팀을 구성하기 쉽다.
- 모듈러 모놀리스와 MSA 스타일에 더 가깝게 맞출 수 있다.
- 메시지 흐름이 문제 영역과 일치한다.
- 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다.

단점
- 유저 정의 코드가 여기저기 널려 있다.

---

### 기술 분할

장점
- 커스텀 코드가 명확하게 분리된다.
- 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다.

단점
- 전역 커플링이 더 높다. 따라서 공통 또는 로컬 컴포넌트 중 하나라도 변경되면 다른 모든 컴포넌트가 영향을 받을 가능성이 높다.
- 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있다.
- 일반적으로 데이터 레벨의 커플링이 높다. 이런 시스템은 대개 애플리케이션 아키텍트, 데이터 아키텍트가 서로 협력하여 단일 데이터베이스를 구성하고 여기에 각종 도메인을 포함시키기 때문에 나중에 아키텍트가 분산 시스템으로 아키텍처를 옮기려고 할 경우 데이터 관계를 파헤치는 작업이 어렵다.

---

## 8.3 개발자 역할

개발자는 아키텍트와 공동 설계한 컴포넌트를 바탕으로 클래스, 함수, 서브 컴포넌트로 더 잘게 나눈다. 

## 8.4 컴포넌트 식별 흐름

### 컴포넌트 식별 주기

초기 컴포넌트 식별 -> 요구사항을 컴포넌트에 할당 -> 역할 및 책임 분석 -> 아키텍처 특성 분석 -> 컴포넌트 재구성

---

## 8.5 컴포넌트 세분도

아키텍트의 가장 어려운 작업 중 하나

컴포넌트를 너무 잘게 나누어 설계하면 컴포넌트 간 통신이 너무 많아지고,
너무 크게 나누면 내부적으로 커플링이 증가해서 배포, 테스트가 어려워지고 모듈성 관점에서도 부정적 영향

---

## 8.6 컴포넌트 설계

초기 설계에서 주의해야 할 점들
- 엔티티 함정 : DB 관계를 APP의 워크플로로 오해할 때 벌어짐
- 액터/액션 접근법 : 뭔가 일을 하는 액터, 그들의 수행하는 액션 식별
- 이벤트 스토밍 : DDD에서 주로 사용. 다양한 컴포넌트가 메시지나 이벤트를 이용해 서로 통신한다 가정
- 워크플로 접근법 : 핵심 역할 식별, 이 역할이 관여하는 워크플로 유형 결정, 그렇게 식별된 활동에 따라 컴포넌트 구축