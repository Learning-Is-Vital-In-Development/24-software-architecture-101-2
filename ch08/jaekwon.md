## 8장. 컴포넌트 기반 사고

모듈 = 연관된 코드의 묶음
컴포넌트 = 아키텍트가 생각하는. 모듈을 물리적으로 구현한 것
서비스 = 다른 종류의 컴포넌트, 배포 가능한 독립적인 단위


### 8.2 아키텍트 역할
아키텍트는 아키텍처를 분할할 줄 알아야하고, 컴포넌트를 식별할 줄 알아야한다

컴포넌트는 클래스나 함수로 구성되며, 이들을 설계하는 업무는 기술리더나 개발자가 할일이다.
아키텍트가 클래스 설계나 세세한 시스템 설계 결정에 참여하기 시작하고, 다른 부서 사람들이 중요한 결정을 내리지 못하게 막는다면 좋지 않다

아키텍처 분할
여기서는 layered package 구조, featured package 구조. 두가지 예시를 들면서 아키텍처를 분할하는 것에 대한 예시와 그 트레이드오프를 설명하고 있다
레이어드 아키텍처 vs 모듈러 모놀리스
기술 분할 vs 도메인 분할

> 근데 보통 생각하기로는..이것도 코드레벨에서의 얘기아닌가? 이것도 아키텍트가 정해준다는게 받아들이기가 어렵다. 그리고 이 두가지 선택지만 소개하는 것은 좀..별로 배울게 없다는 느낌

* 기술 분할
    * 시스템 컴포넌트를 프레젠테이션, 비즈니스 규칙, 퍼시스턴스 등의 기술적 능력에 따라 구성
    * 기술 관심사를 분리함으로써, 디커플링을 달성
    * 하지만 도메인이 여러 기술 레이어에 터져있다

두 스타일은 트레이드오프 관계다


분할 사례 연구: 실리콘 샌드위치

도메인 분할 해본다면
* Purchase
* Promotion
* MakeOrder
* ManageInventory
* Recipes
* Delivery
* Location

* 장점
    * 세부 구현보다 비즈니스 기능에 더 가깝게 모델링된다
    * 역 콘웨이 전략을 활용하여 도메인별 다목적팀 cross-functional team 구성하기 쉽다
    * 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다
    * 메시지 흐름이 문제 영역과 일치한다
    * 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다
* 단점
    * 유저 정의 코드가 여기저기 널려있다

![image](assets/image7.jpeg){width="800" height="300"}


기술 분할 해본다면

* 장점
    * 커스텀 코드가 명확하게 분리된다
    * 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다
* 단점
    * 전역 커플링이 더 높다. 따라서 공통 or 로컬 컴포넌트 중 하나라도 변경되면 다른 모든 컴포넌트가 영향을 받을 수 있다
    * 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있다
    * 일반적으로 데이터 레벨의 커플링이 높다. 이런 시스템은 대게 애플리케이션 아키텍트, 데이터 아키텍트가 서로 협력해서 단일 데이터베이스를 구성하고 여기에 각종 도메인을 포함시키기 때문에 나중에 아키텍트가 분산 시스템으로 아키텍처를 옮기려고 할 경우 데이터 관계를 파헤치는 작업이 어렵다

![image](assets/image8.jpeg){width="800" height="300"}


### 8.3 개발자 역할

설계된 컴포넌트를 바탕으로 클래스, 함수, 서브컴포넌트로 더 잘게 나눈다

### 8.4 컴포넌트 식별 흐름

1. 초기 컴포넌트 식별
2. 요구사항을 컴포넌트에 할당
3. 역할 및 책임 분석
4. 아키텍처 특성 분석
5. 컴포넌트 재구성
6. 3-4-5 반복

한번하고 완성이 아니라, 점차 다듬어가는것이다


* 초기 컴포넌트 식별
    * 소스코드가 생기기 전에 최상위 컴포넌트를 어디서 시작할건지
    * 어느 기능을 어디 도메인에 둘지
* 요구사항을 컴포넌트에 할당
    * 초기 컴포넌트가 식별되면, 요구사항(or 유저스토리)를 컴포넌트에 대입해서 잘 맞는지 확인
    * 이 과성에서 신규 생성, 통합, 분해 등도 할 수 있음
* 역할 및 책임 분석
    * 애플리케이션이 지원해야할 역할과 기능을 고려하여 컴포넌트와 도메인의 세분도(얼마나 잘게 나누었는지)가 적합한지 확인
* 아키텍처 특성 분석
    * 앞서 식별한 아키텍처 특성이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 살펴본다
    * 아키텍처 특성을 고려하여 컴포넌트를 잘게 나눈다
* 컴포넌트 재구성
    * 컴포넌트 설계의 피드백을 반영하여 설계를 반복

### 8.5 컴포넌트 세분도

너무 잘게 나누면 컴포넌트간 통신이 많아지고,
너무 크게 나누면 내부적으로 커플링이 증가, 배포, 테스트가 어려워진다

### 8.6 컴포넌트 설계

컴포넌트를 발견하는 방법과 안티패턴을 소개한다

* 안티패턴
    * 엔티티 함정
        * 데이터베이스 관계를 애플리케이션 워크플로로 오해하지말자
* 접근법
    * 액터/액션 접근법
        * 뭔가 일을 하는 액터와 그들이 수행하는 액션을 식별하여, 유저들이 시스템에서 무슨 일들을 하는지를 찾아낸다
    * 이벤트 스토밍
        * DDD에서 주로 사용되는 컴포넌트 발견 기법
        * 요구사항과 식별된 역할에 따라 시스템에 어떤 이벤트가 일어나는지 파악
        * > DDD에서 사용하는 이벤트 스토밍의 '이벤트'가 이벤트와 메시지를 사용하는 MSA 분산 아키텍처에 잘 어울린다는 뜻이였나??
    * 워크플로 접근법
        * 꼭 메시지 기반 시스템이 아니더라도 사용 가능
        * 핵심 역할을 식별하고, 이 역할이 관여하는 활동을 파악. 이렇게 식별된 활동에 따라 컴포넌트를 구축

### 8.7 컴포넌트 발굴 사례 연구: GGG

3장에서는 이 사례의 아키텍처 특성을 발견했다.

입찰자, 경매인, 시스템. 3가지 역할이 있다

* 입찰자 Bidder
    * 라이브 동영상 스트림과 라이브 입찰 스트림을 보고 입찰한다
* 경매인 Auctionner
    * 라이브 입찰을 시스템에 입력하고, 온라인 입찰을 수신하여, 아이템을 팔린 것으로 표시한다
* 시스템
    * 경매를 시작하고, 결제를 처리하고, 입찰자 활동을 추적한다

그리고 다양한 초기 컴포넌트 세트를 식별할 수 있다

![image](assets/image9.jpeg){width="800" height="400"}


여기서 어떻게 개선해볼 수 있는가?

BidCapture의 경우 입찰자, 경매인 양쪽의 입찰을 모두 진행해준다.
입찰을 동일하게 처리할 수 있으니 합리적이다.
하지만 입찰자는 수천명 단위로 확장될 수 있지만, 경매인은 그렇지 않다. 두 역할이 동일한 확장성, 탄력성이 필요할까?
또한 경매인에게는 신뢰성(접속이 끊어지지 않음)과 가용성(시스템에 접근이 가능해야함)이 더 중요하다


따라서 이렇게 나눠 볼 수 있다. BidCapture, ActionCapture 로 나누었다

![image](assets/image10.jpeg){width="800" height="400"}


### 8.8 아키텍처 퀀텀 딜레마: 모놀리식 vs 분산 아키텍처

다 장단점이 있다.
근본적인 결정은 식별된 아키텍처 퀀텀 수에 따라 다르다
따라서 이걸 결정하기 위해서 초기에 퀀텀을 활용해보면 좋다

> 레이어드 아키텍처 vs 도메인 기준 아키텍처의 비교는 너무 많이 봐와서 지루하다.
> 다만 사례 연구에서, 서로 다른 역할의 요청을 모두 받아주는 컴포넌트를..각각 역할에서 중요한 아키텍처 특성을 뽑아내고 그것에 따라서 컴포넌트를 분리할 수 있다는 아이디어는 좋았다
