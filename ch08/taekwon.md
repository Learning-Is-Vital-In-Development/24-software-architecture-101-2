# CHAPTER 8

# Overview

개발자는 자신의 개발 플랫폼에 따라 여러 가지 방법으로 모듈을 물리적으로 패키징한다. 이렇게 모듈을 물리적으로 패키징한 것을 `컴포넌트`라 한다.

# 컴포넌트 범위

컴포넌트는 아티팩트를 한데 묶어 필요시 중첩시켜 계층화하는, 언어에 특정한 메커니즘을 제공한다.

컴포넌트는 아키텍처에서 `서브시스템`이나 `레이어 형태`로도 나타나며, 많은 `이벤트 프로세서` 를 위한 배포 가능한 작업 단위다.

마이크로서비스 같은 아키텍처에서 서비스는 `배포 가능한` 독립적인 단위를 형성한다.

<aside>
💡 멀티모듈에서 모듈을 나누는 기준은 독립적인 서비스로 배포 가능한 작업의 단위 아닐까.
또한 나눠진 모듈간 이벤트 기반의 호출을 통한다면, 분리가 더 쉬워지지 않을까?

아니면, 에그리거트 등의 구성으로 이후 API 호출등의 분리로도 나누기 쉬워지지 않을까

</aside>

# 아키텍트 역할

아키텍트는 아키텍처 내부의 컴포넌트를 정의, 개선, 관리, 통제하는 역할을 한다.

컴포넌트는 클래스나 함수로 구성되며, 이들을 **설계하는 업무는 기술리더 혹은 개발자가 담당한다**.

## 아키텍처 분할

컴포넌트는 일반적인 적재 메커니즘을 의미하므로 아키텍트는 재량껏 어떤 유형의 분할도 할 수 있다.

`레이어드 아키텍처` 와 `모듈러 모놀리스` 를 예로 들면, 각각 **기술적분할**, **도메인적 분할**로 서로 다른 방법으로 아키텍처를 최상위 분할한 결과이다.

레이어드 아키텍처는 모든 퍼시스턴스 코드가 어느 한 레이어에 있으면 개발자가 퍼시스턴스 관련 코드를 쉽게 찾을 수 있다는 이점이 있으며, 개발자가 이해하기 쉬워서 수많은 조직에서 기본 아키텍처로 자리 잡았다. 이러한 구조의 부수 효과로 콘웨이의 법칙을 실현하는 듯한 자리 배치가 있다.

모듈러 모놀리스(헥사고날은 너무 어렵고, 클린아키텍처는 지키고 싶다)의 경우 DDD에서 비롯되었으며, DDD에서 아키텍트는 서로 독립적으로 분리된 도메인 또는 워크플로를 식별하는데, 이는 MSA의 근본 사상이기도 하다.

<aside>
💡 ***[Modular Monolithic*** Architecture](https://medium.com/design-microservices-architecture-with-patterns/microservices-killer-modular-monolithic-architecture-ac83814f6862)를 지원하는Spring 의 [Modulith](https://spring.io/blog/2022/10/21/introducing-spring-modulith)

</aside>

위 두 아키텍처 패턴 간의 근본적인 차이점 중의 하나가 바로 각각의 개별 패턴을 다루는 최상위 분할의 유형이다.

기술적으로 분리하면(레이어드) 코드베이스가 기능별로 구성되므로 개발자가 코드베이스의 특정 카테고리를 신속하게 찾을 수 있지만, 현실적으로 대부분의 소프트웨어 시스템은 여러 기술/기능을 넘나드는 워크플로를 필요로 한다.

![image](https://github.com/akfls221/24-software-architecture-101-2/assets/71249347/3733d340-b63c-49f4-8473-5ec0cb406807)

<aside>
💡 레이어드 아키텍처의 경우 레어어 간의 의존 방향이 아래로 향하도록 하여 프레젠테이션 레이어 등에서 도메인 객체를 쓰지 못하게 하는것이 좋을거 같다.

</aside>

**두 스타일 모두 어느 것이 더 낫다고 단정지을 순 없다.**

## 분할 사례 연구: 실리콘 샌드위치

컴포넌트 도출 시 아키텍트는 기본적으로 최상위 분할을 어떻게 할지 결정해야 한다.

### 도메인 분할

도메인 분할 아키텍처는 최상위 컴포넌트를 `워크플로` 및 `도메인`에 따라 나눈다.

**[장점]**

- 세부 구현보다 비즈니스 기능에 더 가깝게 모델링 된다.
- 역 콘웨이 전략을 활용하여 도메인별 다목적팀을 구성하기 쉽다.
- 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다.
- 메시지 흐름이 문제 영역과 일치한다.
- 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다.

**[단점]**

- 유저 정의 코드가 여기저기 널려 있다.

### 기술분할

기술 분할 아키텍처는 최상위 컴포넌트를 우커플로가 아닌, 기술적인 능력에 따라 분리하므로 모델- 뷰-컨트롤러(MVC) 또는 상황에 맞게 기술 분할된 레이어로 나타낼 수 있다.

**[장점]**

- 커스텀 코드가 명확하게 분리된다.
- 레이어드 아키텍처 패턴에 더  가깝게 맞출 수 있다.

**[단점]**

- 전역 커플링이 더 높다. 따라서 공통 또는 로컬 컴포넌트 중 하나라도 변경되면 모든 다른 컴포넌트가 영향 받을 가능성이 높다.
- 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있다.
- 일반적으로 데이터 레벨의 커플링이 높다.

## 개발자 역할

개발자는 아키텍트와 공동 설계한 컴포넌트를 바탕으로 클래스, 함수, 서브컴포넌트로 더 잘게 나눈다. 일반적으로 클래스, 함수 설계는 아키텍트, 기술리더, 개발자의 공동 책임이지만 대부분 개발자가 담당한다.

개발자는 아키텍트가 설계한 컴포넌트가 최종판이라고 생각해선 안된다. 초기 설계는 일단 초안으로 보고 차후 구현을 하며 상세한 것들을 밝히고 하나씩 개선해야 한다.

## 컴포넌트 식별 흐름

컴포넌트 식별은 후보를 도출하고 피드백을 통해 다듬어가는 과정을 반복하는 것이 가장 좋다.

아키텍처는 이런 주기를 반복하면서 점점 구체화 된다. 도메인에 따라서 이런 프로세스에 단계가 추가되거나 전체적으로 싹 다 바뀌는 경우도 있다.

### 초기 컴포넌트 식별

아키텍트는 소프트웨어 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 한다.

그 밖에도 아키텍트는 원하는 컴포넌트를 자유롭게 구성하면서 어느 기능을 어디에 둘지 도메인 기능을 매핑 한다.

초기 식별한 컴포넌트들만으로 제대로 된 설계가 나올 가능성은 거의 없으니 아키텍트는 컴포넌트 설계를 이터레이션하면서 조금씩 개선해야 한다.

### 요구사항을 컴포넌트에 할당

초기 컴포넌트 식별 후 요구사항을 대입해서 잘 맞는지 확인한다. 이과정에서 컴포넌트를 새로 만들거나 통합하고 분해하는 일이 생길 수 있다.

다만 설계를 계속 보완할 수 있도록 큼지막한 단위의 기반을 찾으려 노력해야 한다.

### 역할 및 책임 분석

애플리케이션이 지원해야 할 역할과 기능 둘 다 고려해야 컴포넌트와 도메인의 세분도를 맞출 수 있다.

### 아키텍처 특성 분석

컴포턴트에 요구사항을 대입할 때 아키텍트는 아키텍처 특성들이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 살펴봐야 한다.

순수하게 기능적인 관점에서만 컴포넌트를 설계하면 단일 컴포넌트가 도출되지만, 아키텍처 특성들을 분석하면 더 하위 컴포넌트로 잘 게 나눌 수 있는 경우가 있다.

### 컴포넌트 재구성

소프트웨어 설계에서 피드백은 항상 중요하다. 아키텍트는 개발자들과 함께 지속적으로 컴포넌트 설계를 반복해야 한다.

접근 방식이 정말 중요하다. **첫째**, 차후 재설계를 하게 만들지 모를 모든 발견과 특이  사례를 전부 다 고려하기란 사실상 불가능하다. **둘째**, 애플리케이션 구축에 점점 더 깊이 빠질수록 서로의 기능과 역할을 어떻게 조정하면 좋을지 서로 다른 시각으로 바라보게 된다.

## 컴포넌트 세분도

컴포넌트를 너무 잘게 나누어 설계하면 컴포넌트 간 통신이 너무 많아지고, 그렇다고 너무 크게 나누면 내부적으로 커플링이 증가해 배포, 테스트가 어려워지고 모듈성 관점에서도 부정적인 영향을 미친다.(Core, Common 모듈 등)

## 컴포넌트 설계

왕도는 없다. 팀과 조직에서 사용하는 개발 프로세스와 맞물려 다양한 기술과 트레이드오프가 있겠지만, 아키텍트는 아키텍처를 설계하면서 요구사항을 접수하고 애플리케이션을 구성할 굵직굵직한 요소를 그려봐야 한다.

### 컴포넌트 발견

개발자, 비즈니스 분석가, 도메인 전문가와 협력해 시스템에 관한 일반적인 지식과 시스템을 어떻게 분할할지(기술 분할, 도메인 분할) 결정한다.

초기 설계의 목표는 여러 아키텍처 특성을 고려하여 문제 영역을 큼지막한 덩이들로 나누는 것이다.

**[엔티티 함정]**

단순 CRUD 기능만 필요한 시스템은 아키텍트가 프레임워크를 내려 받아 데이터베이스에서 직접 유저 인터페이스를 생성할 수 있다.

엔티티 함정은 아키텍트가 데이터베이스 관계를 애플리케이션의 워크플로로 오해할 때 벌어진다. 이 안티패턴은 일반적으로 애플리케이션의 실제 워크플로에 관한 지식이 얼마나 부족한지 나타낸다.

엔티티 함정에 빠져 생성된 컴포넌트는 너무 큼지막하게 나뉘어지기 때문에 소스 코드의 전체적인 구조와 패키징 관점에서 개발팀에게 지침이 될 만한 것이 하나도 없다.

**[액션/액터 접근법]**

액터/액션 접근법은 아키텍트가 요구사항을 컴포넌트에 매핑할 때 즐겨 쓰는 방법이다.

아키텍트는 애플리케이션에서 뭔가 일을 하는 액터와 그들이 수행하는 액션을 식별하고 시스템의 대표적인 유저와 이들이 세스템에서 어떤 종류의 일을 하는지 찾아내는 기법이다.

이 방법은 요구사항 측면에서 역할이 분명하고 그들이 수행하는 액션의 종류가 확실한 경우에 잘 작동하며 아직도 많이 쓰인다.

**[이벤트 스토밍]**

DDD에서 사용되는 컴포넌트 발견 기법이다. 이벤트 스토밍을 하는 프로젝트에서는 다양한 컴포넌트가 `메시지`나 `이벤트`를 이용해 서로 통신한다고 가정한다.

따라서 팀은 요구사항과 식별된 역할에 따라 시스템에서 어떤 이벤트가 일어나는지 파악하고 컴포넌트를 이벤트와 메시지 핸들러 중심으로 구축한다.

**[워크플로 접근법]**

이벤트 스토밍의 대안으로서, DDD나 메시징을 사용하지 않는, 더 일반화한 방법이다. 이벤트 스토밍과 비슷하지만 메시지 기반 시스템을 구축하는 데 있어서 명시적인 제약조건은 없다.

워크플로 접근법은 핵심 역할을 식별하고 이 역할이 관여하는 워크플로 유형을 결정하며 그렇게 식별된 활동에 따라 컴포넌트를 구축한다.

## 아키텍처 퀀텀 딜레마: 모놀리식이냐, 분산 아키텍처냐

모놀리식 아키텍처는 보통 배포 단위가 하나밖에 없으므로 단일 데이터베이스에 접속하여 실행되는 모든 시스템 기능이 포함 된다.

분산 아키텍처는 이와 정반대로, 자신의 체계를 갖추고 네트워킹 프로토콜을 통해 서로 통신하는 여러 서비스로 구성된다.(배포 단위가 잘게 나뉘어져 있기도 함.)

아키텍처 스타일은 저마다 다양한 트레이드 오프가 있으며 근본적인 결정은 설계 프로세스 중에 식별된 아키텍처 퀀텀 수에 좌우된다.
