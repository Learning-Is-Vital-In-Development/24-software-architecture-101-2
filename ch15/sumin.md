---
marp: true
---
# 공간 기반 아키텍처 스타일
동시 유저 수가 매우 가변적이라서 예측조차 곤란한 애플리케이션에서도 유용하다. 극단적이고 가변적인 확장성 문제는 데이터베이스를 확장하거나, 확장성이 떨어지는 아키텍처에 맞게 캐시 기술을 적용하는 것보다 아키텍처적으로 해결하는 것이 더 낫다.

---
## 토폴로지
* 중앙 DB를 없애는 대신, 복제된 인메모리 데이터 그리드를 활용 : 확장성, 탄력성, 성능을 높일 수 있다.
* 애플리케이션 데이터는 메모리에 둔 상태로 모든 활성 처리 장치들이 데이터를 복제한다.
* 처리장치는 데이터를 업데이트 할때 퍼시스턴스 큐에 메시지를 보내는 식으로 DB에 데이터 비동기 전송
* 중앙 DB가 애플리케이션의 표준 트랜잭션 처리에 관여하지 않아 DB 병목 현상이 사라짐
---
1) 처리장치 : 서비스(클래스), 인메모리그리드, 데이터 복제 엔진
2) 가상 미들웨어 : 아키텍처 내부에서 데이터 동기화 및 요청 처리의 다양한 부분을 제어하는 인프라 담당
* 메시징 그리드 : 입력요청과 세션 상태 관리. 가상 미들웨어에 요청이 유입되면 메시징 그리드는 어느 활성 처리 장치가 요청을 받아 처리할지 결정하여 해당 처리 장치로 요청을 전달한다.
* 데이터 그리드 : 대부분 복제 캐시 역할.
* 처리 그리드 : 단일 비즈니스 요청을 처리할 경우 요청 처리를 오케스트레이트 한다. 요청을 중재/조정
* 배포 관리자 : 부하 조건에 따라 처리 장치 인스턴스를 동적으로 시작/종료하는 컴포넌트
3) 데이터 펌프 : 데이터를 다른 프로세서에 보내 DB를 업데이트. 항상 비동기로 동작하면서 메모리 캐시와 DB의 최종 일관성을 실현, 대부분 메시징 기법으로 구현된다.

---
4) 데이터 라이터 : 데이터 펌프에서 메시지를 받아 DB를 업데이터하는 컴포넌트
5) 데이터 리더 : DB에서 데이터를 읽어 리버스 데이터 펌프를 통해 처리 장치로 실어 나르는 컴포넌트
* 공간 기반 아키텍처에서 데이터 리더가 작동하는 경우
  (1) 동일한 이름의 캐시를 가진 모든 처리 장치 인스턴스가 실패하는 경우
  (2) 동일한 이름의 캐시안에서 모든 처리 장치를 재배포하는 경우
  (3) 복제 캐시에 들어있지 않은 아카이브 데이터를 조회하는 경우

### 데이터 충돌
한 캐시 인스턴스에서 DB가 업데이트되어 다른 캐스 인스턴스에 복제하는 도중에 동일한 데이터가 해당 캐시에서 업데이트되는 현상

---
### 클라우드 대 온프레미스 구현
물리 DB와 데이터를 오프레미스에 그대로 두고 클라우드 기반으 매니지드 환경에서 처리와 가상 미들웨어를 통해 애플리케이션을 ㅍ배호하는 하이브리드 클라우드가 가능하다. 트랜재션은 탄력적인 동적 클라우드 기반의 환경에서 처리하되, 물리적인 데이터 관리, 리포팅, 데이터 분석 데이터는 안전한 로컬 온프레미스 환경에 보관할 수 있다.

### 복제 캐시 대 분산 캐시
* 복제 캐시
    * 각 처리장치에 있는 자체 인메모리 데이터 그리드를 통해 복제 캐시 구현.
    * 속도가 매우 빠르고 높은 수준의 내고장성. 단일 장애점이 없음
    * 데이터량(캐시 크기)이 엄청나게 많거나 캐시 데이터가 너무 빈번하게 업데이트 되면 복제 캐시를 사용할 수 없다.
* 분산 캐시
    * 구현을 위해서는 중앙 캐시를 갖고 있는 전용 외부 서버/서비스가 필요하다.
    * 중앙 캐시 서버에 있는 데이터를 액세스 해야함. 모든 데이터가 한곳에 있고, 복제할 필요가 없어 데이터 일관성 보장.
* 니어 캐시
    * 분산 캐시와 인메모리 데이터 그리드를 접합한 하이브리드 캐스 모델
    * 분산 캐시 : 풀 백킹 캐시, 인메모리 데이터 그리드 : 프런트 캐시
    * 프런트 캐시는 항상 풀 백킹 캐시와 동기화 되지만 각 처리장치에 포함된 프런트 캐시는 동일한 데이터를 공유하는 다른 처리장치와 동기화 되지 않는다. 
